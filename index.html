
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>나만의 립싱크 영상 만들기 v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; -webkit-tap-highlight-color: transparent; }
        input[type="file"] { display: none; }
        .custom-file-upload {
            border: 1px solid #d1d5db; display: inline-block; padding: 8px 12px;
            cursor: pointer; border-radius: 0.375rem; background-color: #f9fafb;
            font-weight: 500; transition: background-color 0.2s;
        }
        .custom-file-upload:hover { background-color: #f3f4f6; }
        .btn-active { background-color: #3b82f6; color: white; border-color: #3b82f6; }
        .btn-active:hover { background-color: #2563eb; }
        .drop-zone { transition: background-color 0.2s, border-color 0.2s; border: 2px dashed #e5e7eb; }
        .drop-zone.drag-over { background-color: #e0f2fe; border-color: #3b82f6; }
        #canvas:active { cursor: grabbing; }
        
        /* --- 타임라인 스타일 --- */
        #playback-timeline-container { cursor: pointer; user-select: none; }
        .layer-container { cursor: crosshair; user-select: none; }

        #playhead {
            transform: translate(-50%, -50%); width: 16px; height: 16px;
            background-color: #3b82f6; border: 2px solid white; border-radius: 50%;
            position: absolute; top: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.2); z-index: 30; pointer-events: none;
        }
        .timeline-cut-bar {
            position: absolute; height: 100%; background-color: rgba(147, 197, 253, 0.5);
            border: 2px solid transparent;
            cursor: move;
            box-sizing: border-box;
            transition: background-color 0.2s, border-color 0.2s, opacity 0.2s;
            overflow: hidden;
        }
        .timeline-cut-bar.active { 
            background-color: rgba(96, 165, 250, 0.6); 
            border-color: #2563eb;
            z-index: 10; 
        }
        .timeline-cut-bar.drag-over-swap {
            background-color: rgba(139, 92, 246, 0.6);
            border-color: #7c3aed;
        }
        .timeline-cut-bar.drag-over-file {
            background-color: rgba(52, 211, 153, 0.6);
            border-color: #059669;
        }
        .timeline-cut-bar.dragging {
            z-index: 50;
            opacity: 0.7;
            border-style: dashed;
        }
        .timeline-thumbnail {
            width: 100%; height: 100%; object-fit: cover; opacity: 0.3; pointer-events: none;
        }
        .cut-number-overlay {
            position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
            font-size: 1.25rem; font-weight: 900; color: black; opacity: 0;
            transition: opacity 0.2s; pointer-events: none; text-shadow: 0 0 2px white;
        }
        .timeline-cut-bar:hover .cut-number-overlay { opacity: 0.2; }
        .timeline-handle {
            position: absolute; top: 0px; width: 16px; height: 100%;
            z-index: 20;
        }
        .timeline-handle.start { left: -8px; cursor: ew-resize;}
        .timeline-handle.end { right: -8px; cursor: ew-resize;}
        #snap-indicator {
            position: absolute; top: 0; height: 100%; width: 2px;
            background-color: #8b5cf6; z-index: 40; display: none;
        }
        .waveform-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0;
        }
        .waveform-progress-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;
        }

        /* --- 레이어 스타일 --- */
        #layer-controls {
             border-right: 1px solid #e5e7eb;
             flex-shrink: 0; /* 너비 고정 */
        }
        .layer-item {
            cursor: pointer; transition: background-color 0.2s;
        }
        .layer-item.active {
            background-color: #e0f2fe;
            color: #0c4a6e;
            font-weight: 600;
        }
        .layer-item:not(.active):hover {
             background-color: #f3f4f6;
        }
        .layer-item.ghost {
            position: absolute;
            opacity: 0.7;
            background-color: #dbeafe;
            pointer-events: none;
            z-index: 100;
        }
        .layer-item .layer-name-span:focus {
            outline: 1px solid #3b82f6;
            background-color: white;
            padding: 2px;
            border-radius: 2px;
        }
        .drop-indicator {
            height: 2px;
            background-color: #3b82f6;
            width: 100%;
        }


        /* --- 트랜스폼 핸들 스타일 --- */
        #transform-handles-container {
            position: absolute; top: 0; left: 0; pointer-events: none;
            width: 100%; height: 100%; z-index: 10;
        }
        .transform-box {
            position: absolute;
            border: 1px solid rgba(59, 130, 246, 0.8);
            pointer-events: all;
        }
        .transform-handle {
            position: absolute;
            width: 16px; height: 16px;
            background-color: white;
            border: 1px solid #3b82f6;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .transform-handle.resize { cursor: nesw-resize; } /* Default, will be overridden */
        .transform-handle.tl { top: 0; left: 0; cursor: nwse-resize; }
        .transform-handle.tr { top: 0; right: 0; cursor: nesw-resize; }
        .transform-handle.bl { bottom: 0; left: 0; cursor: nesw-resize; }
        .transform-handle.br { bottom: 0; right: 0; cursor: nwse-resize; }
        .transform-handle.rotate {
            top: -25px; left: 50%;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" style="color: black;" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>') 10 10, auto;
        }
        
        /* --- 입모양 마커 & 핸들 스타일 --- */
        #mouth-marker {
            position: absolute;
            border: 2px dashed rgba(22, 163, 224, 0.8);
            cursor: grab;
            pointer-events: all;
            z-index: 20;
        }
        #mouth-marker:active { cursor: grabbing; }

        .mouth-handle {
            position: absolute;
            width: 12px; height: 12px;
            background-color: white;
            border: 1px solid #16a3e8;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .mouth-handle.tl { top: 0; left: 0; cursor: nwse-resize; }
        .mouth-handle.br { bottom: 0; right: 0; cursor: nwse-resize; }
        .mouth-handle.rotate {
            top: -20px; left: 50%;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" style="color: black;" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>') 10 10, auto;
        }


        /* hand drawn effect class */
        .hand-drawn { filter: url(#handDrawnFilter); }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <!-- hand-drawn SVG filter definitions -->
    <svg width="0" height="0" style="position:absolute;">
        <defs>
            <filter id="handDrawnFilter">
                <feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="2" seed="1" result="noise"></feTurbulence>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="5" xChannelSelector="R" yChannelSelector="G" result="displacement"></feDisplacementMap>
            </filter>
        </defs>
    </svg>
    <div class="w-full max-w-6xl bg-white rounded-xl shadow-lg p-6 md:p-8 space-y-6">
        <div class="flex justify-between items-center">
            <div class="text-left">
                <h1 class="text-2xl md:text-3xl font-bold text-gray-800">나만의 립싱크 영상 만들기 v2</h1>
                <p class="text-gray-500 mt-2">오디오 파형을 보며 정교하게 컷을 편집하고, 레이어로 순서를 관리하세요.</p>
            </div>
            <div class="flex items-center gap-2">
                <button id="multi-select-toggle" title="다중 선택 모드" class="p-2 rounded-md bg-gray-100 hover:bg-gray-200 text-gray-400">
                    <svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                </button>
                <button id="undo-btn" title="실행 취소 (Ctrl+Z)" class="p-2 rounded-md bg-gray-100 hover:bg-gray-200 text-gray-400 disabled:cursor-not-allowed" disabled>
                    <svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z"></path></svg>
                </button>
                <button id="redo-btn" title="다시 실행 (Ctrl+Shift+Z)" class="p-2 rounded-md bg-gray-100 hover:bg-gray-200 text-gray-400 disabled:cursor-not-allowed" disabled>
                    <svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 15l3-3m0 0l-3-3m3 3H5m16 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                </button>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- 오디오 파일 업로드 -->
            <div id="audio-drop-zone" class="p-4 bg-gray-50 rounded-lg drop-zone">
                <label class="block text-md font-medium text-gray-600 mb-2">♪ 전체 오디오 파일 (1개)</label>
                <div class="flex items-center gap-4"><label for="audio-upload" class="custom-file-upload">파일 선택</label><input id="audio-upload" type="file" accept="audio/*"><span id="audio-filename" class="text-sm text-gray-500">선택된 파일 없음</span></div>
                <div id="audio-loading-status" class="text-sm text-blue-600 mt-2 hidden"></div>
            </div>
             <!-- 프로젝트 저장/불러오기 -->
            <div id="project-drop-zone" class="p-4 bg-gray-50 rounded-lg drop-zone">
                <label class="block text-md font-medium text-gray-600 mb-2">💾 프로젝트 관리</label>
                <div class="flex items-center gap-4">
                    <button id="save-project-btn" class="custom-file-upload">저장</button>
                    <label for="load-project-upload" class="custom-file-upload">불러오기</label>
                    <input id="load-project-upload" type="file" accept=".zip">
                </div>
            </div>
        </div>
        
        <!-- 선택된 컷 편집 섹션 -->
        <div id="cut-editor" class="hidden">
             <div class="flex justify-between items-center border-b pb-2">
                 <h2 class="text-lg font-semibold text-gray-700">선택된 컷 편집하기 (<span id="selected-cut-index">1</span>번 컷)</h2>
                 <button id="delete-cut-btn" class="p-2 text-gray-400 hover:text-red-500 transition-colors" title="선택된 컷 삭제 (Delete)">
                      <svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                 </button>
             </div>
             <div class="space-y-4 mt-4">
                 <div class="p-4 bg-gray-50 rounded-lg">
                      <div class="flex items-center justify-between mb-2">
                          <label class="block text-md font-medium text-gray-600">👄 입 모양 (7단계)</label>
                          <div class="flex items-center gap-4">
                              <div class="flex items-center">
                                  <input id="apply-mouth-only-current-checkbox" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                  <label for="apply-mouth-only-current-checkbox" class="ml-2 block text-sm text-gray-900">현재 컷에만 적용</label>
                              </div>
                              <button id="apply-mouths-to-all-btn" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-1 px-3 rounded-md transition-colors">이 컷의 입 모양을 기본값으로 설정</button>
                          </div>
                      </div>
                      <p class="text-sm font-normal text-gray-500 mb-2">- 여러 파일을 한 번에 선택/드래그하여 순서대로 등록할 수 있습니다.</p>
                      <div id="mouth-previews-container" class="grid grid-cols-2 sm:grid-cols-4 lg:grid-cols-7 gap-2">
                          <!-- 입모양 미리보기는 JS로 생성됩니다 -->
                      </div>
                 </div>
             </div>
        </div>
        
        <div id="no-cut-selected" class="text-center py-10 text-gray-500">
            타임라인의 빈 공간을 드래그하여 첫 컷을 추가하세요.<br>
            컷 선택 후 아래 캔버스에 캐릭터 사진을 드래그 & 드롭할 수 있습니다.
        </div>

        <!-- 실행 섹션 -->
        <div>
            <h2 class="text-lg font-semibold text-gray-700 border-b pb-2">실행하기</h2>
            <div class="mt-4">
                <label for="mode-select" class="block text-md font-medium text-gray-600">립싱크 모드 선택</label>
                <select id="mode-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                    <option value="volume" selected>볼륨 기반 (단순)</option>
                    <option value="vowel">모음/자음 인식 (정교)</option>
                </select>
            </div>
            
            <!-- 타임라인 UI -->
            <div id="timeline-controls" class="mt-4 space-y-2">
                <div class="flex">
                    <div id="layer-controls-placeholder" class="w-32 flex-shrink-0"></div>
                    <div id="playback-timeline-wrapper" class="flex-grow relative">
                        <div id="playback-timeline-container" class="w-full h-6 bg-gray-200 rounded-lg relative flex items-center">
                            <div id="playhead" style="left: 0px;"></div>
                        </div>
                    </div>
                </div>
                <div class="flex border rounded-lg bg-gray-50">
                    <div id="layer-controls" class="w-32 p-2 space-y-2">
                        <div id="layer-list" class="space-y-1"></div>
                        <button id="add-layer-btn" class="w-full text-sm py-1 px-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">+ 레이어 추가</button>
                    </div>
                    <div id="cut-timeline-container" class="flex-grow h-auto relative overflow-hidden touch-none">
                        <div id="timeline-viewport" class="w-full h-full relative overflow-auto">
                            <div id="timeline-content" class="relative">
                                <!-- Layers will be dynamically inserted here -->
                            </div>
                        </div>
                        <div id="snap-indicator"></div>
                    </div>
                </div>
                 <div class="text-right text-sm text-gray-500 font-mono">
                     <span id="current-time">00:00</span> / <span id="total-duration">00:00</span>
                 </div>
            </div>

            <div id="canvas-container" class="mt-2 bg-gray-200 rounded-lg overflow-hidden relative touch-none">
                <canvas id="canvas" class="w-full h-auto block"></canvas>
                <div id="transform-handles-container"></div>
                <div id="mouth-marker" class="absolute hidden"></div>
                <div id="canvas-drop-overlay" class="absolute inset-0 bg-blue-500 bg-opacity-20 border-4 border-dashed border-blue-600 hidden items-center justify-center pointer-events-none text-center">
                    <p class="text-blue-800 font-bold text-2xl">여기에 캐릭터 사진을 드롭하세요</p>
                </div>
            </div>
            <div id="controllers" class="hidden mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- ✨ 배경 이미지 섹션 이동 ✨ -->
                <div class="p-4 bg-gray-50 rounded-lg md:col-span-2">
                    <div class="flex items-center justify-between mb-2">
                        <label class="block text-md font-medium text-gray-600">🖼️ 배경 이미지</label>
                        <div class="flex items-center gap-2">
                            <button id="apply-bg-to-all-btn" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-1 px-3 rounded-md transition-colors">모든 컷에 적용</button>
                            <button id="remove-bg-btn" class="text-xs bg-red-100 hover:bg-red-200 text-red-700 font-semibold py-1 px-3 rounded-md transition-colors">배경 제거</button>
                        </div>
                    </div>
                    <div class="flex items-center gap-4">
                        <div id="bg-drop-zone" class="w-24 h-16 rounded-lg drop-zone flex items-center justify-center bg-white border">
                            <img id="bg-preview" src="https://placehold.co/96x64/e2e8f0/cbd5e0?text=배경" class="w-full h-full object-contain rounded-md">
                        </div>
                        <div class="flex-1">
                            <label for="bg-upload" class="custom-file-upload w-full text-center">파일 선택</label>
                            <input id="bg-upload" type="file" accept="image/*">
                            <select id="bg-fit-select" class="mt-2 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                                <option value="cover">채우기 (Cover)</option>
                                <option value="contain">맞추기 (Contain)</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="p-4 bg-gray-50 rounded-lg">
                    <div class="flex items-center justify-between">
                        <label for="character-size-slider" class="block text-md font-medium text-gray-600">캐릭터 크기: <span id="character-size-value">100</span>%</label>
                        <button id="toggle-lock-btn" class="p-2 rounded-md transition-colors text-gray-500" title="캐릭터 이동 잠금/해제">
                            <svg id="lock-icon" class="h-6 w-6 pointer-events-none" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                            </svg>
                            <svg id="unlock-icon" class="h-6 w-6 hidden pointer-events-none" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M8 11V7a4 4 0 118 0m-4 8v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2z" />
                            </svg>
                        </button>
                    </div>
                    <input id="character-size-slider" type="range" min="10" max="500" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2">
                </div>
                <div class="p-4 bg-gray-50 rounded-lg">
                    <label for="mouth-size-slider" class="block text-md font-medium text-gray-600">입 모양 크기: <span id="mouth-size-value">25</span>%</label>
                    <input id="mouth-size-slider" type="range" min="1" max="50" value="25" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2">
                </div>
                <div class="p-4 bg-gray-50 rounded-lg col-span-1 md:col-span-2">
                     <div class="flex items-center justify-between">
                         <div class="flex items-center gap-4">
                             <label for="hand-drawn-toggle" class="text-md font-medium text-gray-600 flex items-center">
                                 <input type="checkbox" id="hand-drawn-toggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" checked>
                                 <span class="ml-2">손그림 효과 (Line-Boiling)</span>
                             </label>
                         </div>
                         <label for="hand-drawn-intensity-slider" class="block text-sm font-medium text-gray-600">강도: <span id="hand-drawn-intensity-value">5</span></label>
                     </div>
                     <input id="hand-drawn-intensity-slider" type="range" min="0" max="20" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2">
                </div>
            </div>
            <div class="mt-4 flex gap-4">
                <button id="animate-btn" class="w-full py-3 text-white font-bold rounded-lg transition-colors duration-300 bg-gray-400 cursor-not-allowed" disabled>▶︎ 애니메이션 시작</button>
                <button id="export-btn" class="w-1/3 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg transition-colors">내보내기</button>
                <button id="reset-btn" class="w-1/3 py-3 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-lg transition-colors">초기화</button>
            </div>
        </div>
    </div>
    <div id="notification" class="fixed bottom-5 right-5 bg-gray-800 text-white py-2 px-4 rounded-lg shadow-lg transition-opacity duration-300 opacity-0 pointer-events-none z-50"></div>
    
    <!-- 내보내기 모달 -->
    <div id="export-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h3 class="text-lg font-bold text-gray-800">영상으로 내보내기</h3>
            <div class="mt-4 space-y-2">
                <label class="block text-md font-medium text-gray-600">화질 선택</label>
                <select id="export-quality-select" class="block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                    <option value="1080">1080p (FHD)</option>
                    <option value="720" selected>720p (HD)</option>
                    <option value="360">360p (SD)</option>
                </select>
            </div>
            <div class="mt-4 flex items-center">
                <input id="export-selection-checkbox" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                <label for="export-selection-checkbox" class="ml-2 block text-sm text-gray-900">선택영역 내보내기</label>
            </div>
            <div id="export-progress-container" class="mt-4 hidden">
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="export-progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <p id="export-status-text" class="text-center text-sm text-gray-600 mt-2"></p>
            </div>
            <div class="mt-6 flex justify-end gap-4">
                <button id="export-close-btn" class="py-2 px-4 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">닫기</button>
                <button id="export-start-btn" class="py-2 px-4 bg-blue-500 text-white rounded-lg hover:bg-blue-600">시작</button>
                <a id="export-download-link" class="hidden"></a>
                <button id="export-download-btn" class="py-2 px-4 bg-green-500 text-white rounded-lg hover:bg-green-600 hidden">다운로드</button>
            </div>
        </div>
    </div>

    <script>
        // 전역 오디오 컨텍스트 (성능을 위해 한 번만 생성)
        const GLOBAL_AUDIO_CONTEXT = new (window.AudioContext || window.webkitAudioContext)();

        const state = {
            mode: 'volume',
            layers: [], // { id: number, name: string }
            activeLayerIndex: 0,
            cuts: [], // { ..., layerId: number }
            selectedCutIds: [],
            lastSelectedCutId: null,
            audioFile: null,
            audioFileName: '',
            audioDuration: 0,
            audioBuffer: null, // 오디오 버퍼 저장
            audioPeakData: [], // 파형 데이터를 저장할 배열
            defaultMouthImgs: Array.from({length: 7}, () => ({ src: null, fileName: null })), // 기본 입모양 저장 (객체로 변경)
            isAnimating: false,
            animationFrameId: null,
            analyser: null,
            source: null,
            frequencyData: null,
            audioElement: null,
            isDraggingPlayhead: false,
            currentlyDisplayedCutIds: [], // 여러 레이어를 위해 배열로 변경
            timelineZoom: 1.0, // 줌 레벨
            timelinePan: 0, // 픽셀 단위 패닝
            isPanning: false,
            lastPanX: 0,
            draggedCutForSwap: null,
            dropTargetCutForSwap: null,
            draggedOverCutBarForFile: null, // 파일 드래그 오버 상태 추가
            undoStack: [],
            redoStack: [],
            isHandDrawnEffect: true, // 손그림 효과 On/Off 상태
            handDrawnIntensity: 5, // 손그림 효과 강도
            activeTransform: null, // {cutId, type: 'character-move'|'mouth-move'|'resize'|'rotate', ...}
            isMultiSelectMode: false, // 다중 선택 모드
        };

        const dom = {
            audioUpload: document.getElementById('audio-upload'),
            audioFilename: document.getElementById('audio-filename'),
            audioLoadingStatus: document.getElementById('audio-loading-status'),
            cutEditor: document.getElementById('cut-editor'),
            noCutSelected: document.getElementById('no-cut-selected'),
            deleteCutBtn: document.getElementById('delete-cut-btn'),
            controllers: document.getElementById('controllers'),
            selectedCutIndex: document.getElementById('selected-cut-index'),
            mouthPreviewsContainer: document.getElementById('mouth-previews-container'),
            modeSelect: document.getElementById('mode-select'),
            canvas: document.getElementById('canvas'),
            ctx: document.getElementById('canvas').getContext('2d'),
            mouthMarker: document.getElementById('mouth-marker'),
            characterSizeSlider: document.getElementById('character-size-slider'),
            characterSizeValue: document.getElementById('character-size-value'),
            mouthSizeSlider: document.getElementById('mouth-size-slider'),
            mouthSizeValue: document.getElementById('mouth-size-value'),
            animateBtn: document.getElementById('animate-btn'),
            resetBtn: document.getElementById('reset-btn'),
            timelineControls: document.getElementById('timeline-controls'),
            timelineViewport: document.getElementById('timeline-viewport'),
            timelineContent: document.getElementById('timeline-content'),
            playbackTimelineContainer: document.getElementById('playback-timeline-container'),
            cutTimelineContainer: document.getElementById('cut-timeline-container'),
            playhead: document.getElementById('playhead'),
            snapIndicator: document.getElementById('snap-indicator'),
            currentTime: document.getElementById('current-time'),
            totalDuration: document.getElementById('total-duration'),
            toggleLockBtn: document.getElementById('toggle-lock-btn'),
            lockIcon: document.getElementById('lock-icon'),
            unlockIcon: document.getElementById('unlock-icon'),
            canvasContainer: document.getElementById('canvas-container'),
            canvasDropOverlay: document.getElementById('canvas-drop-overlay'),
            applyMouthsToAllBtn: document.getElementById('apply-mouths-to-all-btn'),
            notification: document.getElementById('notification'),
            undoBtn: document.getElementById('undo-btn'),
            redoBtn: document.getElementById('redo-btn'),
            multiSelectToggle: document.getElementById('multi-select-toggle'),
            saveProjectBtn: document.getElementById('save-project-btn'),
            loadProjectUpload: document.getElementById('load-project-upload'),
            bgUpload: document.getElementById('bg-upload'),
            bgDropZone: document.getElementById('bg-drop-zone'),
            bgPreview: document.getElementById('bg-preview'),
            bgFitSelect: document.getElementById('bg-fit-select'),
            removeBgBtn: document.getElementById('remove-bg-btn'),
            applyBgToAllBtn: document.getElementById('apply-bg-to-all-btn'),
            applyMouthOnlyCurrentCheckbox: document.getElementById('apply-mouth-only-current-checkbox'),
            exportBtn: document.getElementById('export-btn'),
            exportModal: document.getElementById('export-modal'),
            exportQualitySelect: document.getElementById('export-quality-select'),
            exportProgressContainer: document.getElementById('export-progress-container'),
            exportProgressBar: document.getElementById('export-progress-bar'),
            exportStatusText: document.getElementById('export-status-text'),
            exportCloseBtn: document.getElementById('export-close-btn'),
            exportStartBtn: document.getElementById('export-start-btn'),
            exportDownloadLink: document.getElementById('export-download-link'),
            exportDownloadBtn: document.getElementById('export-download-btn'),
            exportSelectionCheckbox: document.getElementById('export-selection-checkbox'),
            handDrawnToggle: document.getElementById('hand-drawn-toggle'),
            handDrawnIntensitySlider: document.getElementById('hand-drawn-intensity-slider'),
            handDrawnIntensityValue: document.getElementById('hand-drawn-intensity-value'),
            displacementMap: document.querySelector('#handDrawnFilter feDisplacementMap'),
            layerList: document.getElementById('layer-list'),
            addLayerBtn: document.getElementById('add-layer-btn'),
            transformHandlesContainer: document.getElementById('transform-handles-container'),
            layerControls: document.getElementById('layer-controls'),
        };
        
        // --- 함수 정의 ---
        
        // --- Pointer Event Normalization ---
        function unify(e) {
            return e.changedTouches ? e.changedTouches[0] : e;
        }
        
        // --- 시간 <-> 픽셀 변환 함수 (줌/팬 적용) ---
        function timeToPx(time) {
            if (state.audioDuration === 0) return 0;
            const timelineWidth = dom.timelineViewport.offsetWidth;
            return (time / state.audioDuration) * (timelineWidth * state.timelineZoom) - state.timelinePan;
        }

        function pxToTime(px) {
            if (state.audioDuration === 0) return 0;
            const timelineWidth = dom.timelineViewport.offsetWidth;
            return ((px + state.timelinePan) / (timelineWidth * state.timelineZoom)) * state.audioDuration;
        }

        function getLayerIndexFromId(layerId) {
            return state.layers.findIndex(l => l.id === layerId);
        }

        function prepareCanvasForCut(cut) {
            const canvas = dom.canvas;
            const charImg = cut.characterImg;
            if (!charImg || !charImg.complete || charImg.naturalWidth === 0) {
                canvas.height = canvas.width * (9 / 16);
                return;
            }
            canvas.height = (canvas.width * charImg.naturalHeight) / charImg.naturalWidth;
        }

        function drawScene(cutsToDraw, mouthMap = new Map()) {
            const canvas = dom.canvas;
            const ctx = dom.ctx;
            const parentWidth = canvas.parentElement.clientWidth;
            canvas.width = parentWidth > 0 ? parentWidth : 600;
            
            // 캔버스 크기 설정 (가장 아래 레이어의 캐릭터 이미지 기준)
            const sortedCuts = [...cutsToDraw].sort((a, b) => getLayerIndexFromId(a.layerId) - getLayerIndexFromId(b.layerId));
            const baseCut = sortedCuts[0] || state.cuts.find(c => c.id === state.lastSelectedCutId);

            if (baseCut && baseCut.characterImg.src) {
                prepareCanvasForCut(baseCut);
            } else {
                canvas.height = canvas.width * (9 / 16);
            }

            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 레이어 순서대로(오름차순) 정렬하여 그리기 -> 인덱스가 높은(아래쪽) 레이어가 먼저 그려짐
            sortedCuts.forEach(cut => {
                drawBackground(cut);
                drawCharacter(cut);
                const mouthImg = mouthMap.get(cut.id) || cut.mouthImgs[0]?.img;
                if (mouthImg && mouthImg.src && mouthImg.complete) {
                    drawMouth(cut, mouthImg);
                }
            });
            
            // 마지막으로 선택된 컷의 트랜스폼 핸들 그리기
            const lastSelectedCut = state.cuts.find(c => c.id === state.lastSelectedCutId);
            if (lastSelectedCut) {
                 updateTransformHandles(lastSelectedCut);
                 updateMouthMarker(lastSelectedCut);
            } else {
                 dom.transformHandlesContainer.innerHTML = '';
                 dom.mouthMarker.classList.add('hidden');
            }
        }

        function drawInitialCanvas() {
            const currentTime = state.audioElement ? state.audioElement.currentTime : 0;
            const activeCuts = state.cuts.filter(cut => currentTime >= cut.startTime && currentTime < cut.endTime);
            state.currentlyDisplayedCutIds = activeCuts.map(c => c.id);
            
            const mouthMap = new Map(activeCuts.map(c => [c.id, c.mouthImgs[0]?.img]));
            
            if (activeCuts.length > 0) {
                drawScene(activeCuts, mouthMap);
            } else {
                // 활성 컷이 없을 때, 선택된 컷이 있으면 보여주기
                const selectedCut = state.cuts.find(c => c.id === state.lastSelectedCutId);
                if (selectedCut) {
                    drawScene([selectedCut], new Map([[selectedCut.id, selectedCut.mouthImgs[0]?.img]]));
                } else {
                    drawScene([]);
                }
            }
        }

        function drawBackground(cut, targetCanvas = dom.canvas, targetCtx = dom.ctx) {
            if (!cut.backgroundImage || !cut.backgroundImage.src || !cut.backgroundImage.complete) return;
            const img = cut.backgroundImage;
            const canvas = targetCanvas;
            const ctx = targetCtx;

            const canvasAspect = canvas.width / canvas.height;
            const imgAspect = img.naturalWidth / img.naturalHeight;
            let sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight;

            if (cut.backgroundFit === 'cover') {
                if (canvasAspect > imgAspect) {
                    sWidth = img.naturalWidth;
                    sHeight = img.naturalWidth / canvasAspect;
                    sx = 0;
                    sy = (img.naturalHeight - sHeight) / 2;
                } else {
                    sHeight = img.naturalHeight;
                    sWidth = img.naturalHeight * canvasAspect;
                    sy = 0;
                    sx = (img.naturalWidth - sWidth) / 2;
                }
                dx = 0; dy = 0;
                dWidth = canvas.width; dHeight = canvas.height;
            } else { // contain
                if (canvasAspect > imgAspect) {
                    dHeight = canvas.height;
                    dWidth = dHeight * imgAspect;
                    dy = 0;
                    dx = (canvas.width - dWidth) / 2;
                } else {
                    dWidth = canvas.width;
                    dHeight = dWidth / imgAspect;
                    dx = 0;
                    dy = (canvas.height - dHeight) / 2;
                }
                sx = 0; sy = 0;
                sWidth = img.naturalWidth; sHeight = img.naturalHeight;
            }
            ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        }

        function drawCharacter(cut, targetCanvas = dom.canvas, targetCtx = dom.ctx) {
            if (!cut.characterImg.src || !cut.characterImg.complete) return;
            const img = cut.characterImg;
            const canvas = targetCanvas;
            const ctx = targetCtx;

            const scaledWidth = canvas.width * cut.characterScale;
            const scaledHeight = (img.height * scaledWidth) / img.width;

            ctx.save();
            // 이동 -> 회전 -> 그리기
            const centerX = cut.characterOffsetX + canvas.width / 2;
            const centerY = cut.characterOffsetY + canvas.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate(cut.rotation * Math.PI / 180);
            ctx.translate(-centerX, -centerY);

            const drawX = cut.characterOffsetX - (scaledWidth - canvas.width) / 2;
            const drawY = cut.characterOffsetY - (scaledHeight - canvas.height) / 2;
            
            ctx.drawImage(img, drawX, drawY, scaledWidth, scaledHeight);
            ctx.restore();
        }

        function drawMouth(cut, img, targetCanvas = dom.canvas, targetCtx = dom.ctx) {
            if (!img || !img.complete) return;
            const canvas = targetCanvas;
            const ctx = targetCtx;
            
            ctx.save();
            // 1. 캐릭터의 중심으로 이동하고 캐릭터 회전 적용
            const charCenterX = cut.characterOffsetX + canvas.width / 2;
            const charCenterY = cut.characterOffsetY + canvas.height / 2;
            ctx.translate(charCenterX, charCenterY);
            ctx.rotate(cut.rotation * Math.PI / 180);

            // 2. 캐릭터의 회전된 좌표계 내에서 입의 상대적 위치 계산
            const mouthRelativeX = (cut.mouthX - 0.5) * canvas.width;
            const mouthRelativeY = (cut.mouthY - 0.5) * canvas.height;

            // 3. 입의 중심으로 이동하고 입 회전 적용
            ctx.translate(mouthRelativeX, mouthRelativeY);
            ctx.rotate(cut.mouthRotation * Math.PI / 180);

            // 4. 현재 위치(0,0)를 중심으로 입 이미지 그리기
            const mouthWidth = canvas.width * cut.mouthSize;
            const mouthHeight = mouthWidth / (img.naturalWidth / img.naturalHeight || 1);
            ctx.globalCompositeOperation = 'multiply';
            ctx.drawImage(img, -mouthWidth / 2, -mouthHeight / 2, mouthWidth, mouthHeight);
            
            ctx.restore();
        }

        function updateMouthMarker(cut) {
            if (!cut || !cut.characterImg.src || state.isAnimating) {
                dom.mouthMarker.innerHTML = '';
                dom.mouthMarker.classList.add('hidden');
                return;
            }

            // 입 모양 크기 반영
            const firstMouthImg = cut.mouthImgs.find(m => m.img.src)?.img || { naturalWidth: 2, naturalHeight: 1 };
            const mouthWidthPx = dom.canvas.width * cut.mouthSize;
            const mouthHeightPx = mouthWidthPx / (firstMouthImg.naturalWidth / firstMouthImg.naturalHeight || 2);
            
            // 마커의 절대 위치 계산 (캐릭터 회전 포함)
            const charCenterX = cut.characterOffsetX + dom.canvas.width / 2;
            const charCenterY = cut.characterOffsetY + dom.canvas.height / 2;
            const mouthRelativeX = (cut.mouthX - 0.5) * dom.canvas.width;
            const mouthRelativeY = (cut.mouthY - 0.5) * dom.canvas.height;
            const angleRad = cut.rotation * Math.PI / 180;
            const rotatedMouthX = mouthRelativeX * Math.cos(angleRad) - mouthRelativeY * Math.sin(angleRad);
            const rotatedMouthY = mouthRelativeX * Math.sin(angleRad) + mouthRelativeY * Math.cos(angleRad);
            const finalX = charCenterX + rotatedMouthX;
            const finalY = charCenterY + rotatedMouthY;

            dom.mouthMarker.style.width = `${mouthWidthPx}px`;
            dom.mouthMarker.style.height = `${mouthHeightPx}px`;
            dom.mouthMarker.style.left = `${finalX}px`;
            dom.mouthMarker.style.top = `${finalY}px`;
            dom.mouthMarker.style.transform = `translate(-50%, -50%) rotate(${cut.rotation + cut.mouthRotation}deg)`;
            
            // 핸들 생성 (캐릭터가 잠겨있을 때만)
            dom.mouthMarker.innerHTML = '';
            if (cut.isCharacterLocked) {
                 ['tl', 'br', 'rotate'].forEach(type => {
                    const handle = document.createElement('div');
                    handle.className = `mouth-handle ${type}`;
                    handle.dataset.type = type;
                    dom.mouthMarker.appendChild(handle);
                });
            }

            dom.mouthMarker.classList.remove('hidden');
        }

        function renderTimeline() {
            const timelineContent = dom.timelineContent;
            timelineContent.innerHTML = '';
            if (state.audioDuration === 0) return;

            const timelineWidth = dom.timelineViewport.offsetWidth * state.timelineZoom;
            timelineContent.style.width = `${timelineWidth}px`;
            timelineContent.style.height = `${state.layers.length * 52}px`; // 52px = h-12 (48) + my-1 (8)
            dom.timelineViewport.style.height = `${Math.min(260, state.layers.length * 52)}px`;

            if (state.audioElement) {
                updatePlaybackTime(state.audioElement.currentTime, state.audioDuration);
            } else {
                updatePlaybackTime(0, state.audioDuration);
            }
            
            state.layers.forEach((layer, layerIndex) => {
                const layerContainer = document.createElement('div');
                layerContainer.className = 'layer-container w-full h-12 bg-gray-100 rounded-lg relative my-1';
                layerContainer.dataset.layerId = layer.id;

                const waveformContainer = document.createElement('div');
                waveformContainer.className = 'absolute inset-0 pointer-events-none';
                
                const waveformCanvas = document.createElement('canvas');
                waveformCanvas.className = 'waveform-canvas';
                const waveformProgressCanvas = document.createElement('canvas');
                waveformProgressCanvas.className = 'waveform-progress-canvas';
                
                waveformContainer.append(waveformCanvas, waveformProgressCanvas);
                layerContainer.appendChild(waveformContainer);

                const cutBarsContainer = document.createElement('div');
                cutBarsContainer.className = 'relative w-full h-full';
                layerContainer.appendChild(cutBarsContainer);

                const cutsInLayer = state.cuts.filter(c => c.layerId === layer.id).sort((a,b) => a.startTime - b.startTime);

                cutsInLayer.forEach((cut, index) => {
                    const bar = document.createElement('div');
                    const isSelected = state.selectedCutIds.includes(cut.id);
                    bar.className = `timeline-cut-bar ${isSelected ? 'active' : ''}`;
                    bar.dataset.id = cut.id;
                    
                    if (cut.characterImg.src) {
                        const thumbnail = new Image();
                        thumbnail.src = cut.characterImg.src;
                        thumbnail.className = 'timeline-thumbnail';
                        bar.appendChild(thumbnail);
                    }

                    const numberOverlay = document.createElement('div');
                    numberOverlay.className = 'cut-number-overlay';
                    numberOverlay.textContent = index + 1;
                    bar.appendChild(numberOverlay);

                    const startHandle = document.createElement('div');
                    startHandle.className = 'timeline-handle start';
                    const endHandle = document.createElement('div');
                    endHandle.className = 'timeline-handle end';
                    
                    bar.appendChild(startHandle);
                    bar.appendChild(endHandle);

                    const barLeftPx = timeToPx(cut.startTime);
                    const barRightPx = timeToPx(cut.endTime);
                    const barWidthPx = barRightPx - barLeftPx;

                    bar.style.left = `${barLeftPx}px`;
                    bar.style.width = `${barWidthPx}px`;

                    cutBarsContainer.appendChild(bar);
                });
                
                timelineContent.appendChild(layerContainer);
                drawWaveform(waveformCanvas, waveformProgressCanvas);
            });
            drawWaveformProgress();
        }
        
        function updateEditorUI() {
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);

            if (!cut) {
                dom.cutEditor.classList.add('hidden');
                dom.controllers.classList.add('hidden');
                dom.noCutSelected.classList.remove('hidden');
                dom.transformHandlesContainer.innerHTML = ''; // 핸들 숨기기
                return;
            }
            
            dom.cutEditor.classList.remove('hidden');
            dom.controllers.classList.remove('hidden');
            dom.noCutSelected.classList.add('hidden');
            
            const layerIndex = getLayerIndexFromId(cut.layerId);
            const sortedCuts = [...state.cuts].sort((a, b) => a.startTime - b.startTime);
            const cutIndex = sortedCuts.findIndex(c => c.id === lastSelectedId) + 1;
            const selectionCount = state.selectedCutIds.length;
            dom.selectedCutIndex.textContent = selectionCount > 1 ? `${selectionCount}개 선택됨` : `${cutIndex}번 컷 (레이어 ${layerIndex + 1})`;

            // 배경 UI 업데이트
            dom.bgPreview.src = cut.backgroundImage.src || "https://placehold.co/96x64/e2e8f0/cbd5e0?text=배경";
            dom.bgFitSelect.value = cut.backgroundFit;

            // 입모양 미리보기 업데이트
            dom.mouthPreviewsContainer.innerHTML = '';
            const mouthLabels = ['1. 닫힘', '2. 기본', '3. ㅅ/ㅊ', '4. 이', '5. 에', '6. 아', '7. 오/우'];
            cut.mouthImgs.forEach((imgData, i) => {
                const html = `
                    <div id="mouth-lvl${i+1}-drop-zone" class="text-center p-2 rounded-lg drop-zone">
                        <label for="mouth-lvl${i+1}-upload" class="custom-file-upload w-full text-center text-xs">${mouthLabels[i]}</label>
                        <input id="mouth-lvl${i+1}-upload" type="file" accept="image/*" multiple>
                        <div class="relative mt-2 group">
                            <img id="mouth-lvl${i+1}-preview" src="${imgData.img.src || `https://placehold.co/80x40/e2e8f0/cbd5e0?text=${i+1}`}" class="w-full h-10 mx-auto rounded-md object-contain border">
                            <button data-mouth-index="${i}" class="delete-mouth-btn ${imgData.img.src ? 'flex' : 'hidden'} group-hover:flex absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-4 h-4 items-center justify-center text-xs leading-none">&times;</button>
                        </div>
                    </div>
                `;
                dom.mouthPreviewsContainer.insertAdjacentHTML('beforeend', html);
            });


            dom.characterSizeSlider.value = cut.characterScale * 100;
            dom.characterSizeValue.textContent = Math.round(cut.characterScale * 100);
            dom.mouthSizeSlider.value = cut.mouthSize * 100;
            dom.mouthSizeValue.textContent = Math.round(cut.mouthSize * 100);
            updateLockUI(cut);
            updateTransformHandles(cut);
        }
        
        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
        }

        function updatePlaybackTime(currentTime, duration) {
            dom.currentTime.textContent = formatTime(currentTime);
            dom.totalDuration.textContent = formatTime(duration);
            
            const interactiveWidth = dom.playbackTimelineContainer.offsetWidth;

            const progressPx = duration > 0 ? (currentTime / duration) * interactiveWidth : 0;
            dom.playhead.style.left = `${progressPx}px`;

            drawWaveformProgress();
        }

        function checkAllFilesReady() {
            const isReady = state.cuts.length > 0 && state.audioFile && state.cuts.some(c => c.characterImg.src);
            dom.animateBtn.disabled = !isReady;
            dom.animateBtn.classList.toggle('btn-active', isReady);
            dom.animateBtn.classList.toggle('bg-gray-400', !isReady);
            dom.animateBtn.classList.toggle('cursor-not-allowed', !isReady);
        }

        function addNewCut(startTime, endTime, layerId) {
            const newCutId = Date.now() + Math.random(); // ID 고유성 강화
            const newCut = {
                id: newCutId,
                startTime: startTime,
                endTime: endTime,
                layerId: layerId,
                characterImg: new Image(),
                mouthImgs: state.defaultMouthImgs.map(defaultImgData => {
                    const newImg = new Image();
                    if (defaultImgData.src) {
                        newImg.src = defaultImgData.src;
                    }
                    return { img: newImg, fileName: defaultImgData.fileName };
                }),
                backgroundImage: new Image(),
                backgroundFit: 'cover',
                mouthX: 0.5, mouthY: 0.7, mouthSize: 0.25, mouthRotation: 0,
                characterScale: 1.0, characterOffsetX: 0, characterOffsetY: 0, rotation: 0,
                isCharacterLocked: true,
            };
            state.cuts.push(newCut);
            state.selectedCutIds = [newCutId];
            state.lastSelectedCutId = newCutId;
            setActiveLayer(getLayerIndexFromId(layerId));
            renderTimeline();
            updateEditorUI();
            drawInitialCanvas();
            saveStateForUndo("컷 추가");
        }

        function deleteSelectedCuts() {
            if (state.selectedCutIds.length === 0) return;
            state.cuts = state.cuts.filter(cut => !state.selectedCutIds.includes(cut.id));
            state.selectedCutIds = [];
            state.lastSelectedCutId = null;
            renderTimeline();
            updateEditorUI();
            drawInitialCanvas();
            checkAllFilesReady();
            saveStateForUndo("컷 삭제");
        }

        async function handleAudioUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            state.audioFile = file;
            state.audioFileName = file.name;
            dom.audioFilename.textContent = file.name;
            
            dom.audioLoadingStatus.textContent = "오디오 분석 중...";
            dom.audioLoadingStatus.classList.remove('hidden');

            try {
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await GLOBAL_AUDIO_CONTEXT.decodeAudioData(arrayBuffer);
                state.audioDuration = audioBuffer.duration;
                state.audioBuffer = audioBuffer;
                
                const peakData = analyzeAudio(audioBuffer);
                state.audioPeakData = peakData;

                updatePlaybackTime(0, state.audioDuration);
                renderTimeline();
            } catch (err) {
                console.error("오디오 파일 분석 오류:", err);
                showNotification("오디오 파일을 분석하는 데 실패했습니다.", true);
            } finally {
                dom.audioLoadingStatus.classList.add('hidden');
            }
            checkAllFilesReady();
        }

        function processCharacterImage(file, cut) {
            if (!file || !file.type.startsWith('image/')) {
                showNotification('이미지 파일만 업로드할 수 있습니다.', true);
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const imgStore = cut.characterImg;
                imgStore.src = event.target.result;
                imgStore.fileName = file.name;
                imgStore.onload = () => {
                    updateEditorUI();
                    drawInitialCanvas();
                    checkAllFilesReady();
                    renderTimeline();
                    saveStateForUndo("캐릭터 이미지 변경");
                };
            };
            reader.readAsDataURL(file);
        }

        function processBackgroundImage(file, cut) {
            if (!file || !file.type.startsWith('image/')) {
                showNotification('이미지 파일만 업로드할 수 있습니다.', true);
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                cut.backgroundImage.src = event.target.result;
                cut.backgroundImage.fileName = file.name;
                cut.backgroundImage.onload = () => {
                    updateEditorUI();
                    drawInitialCanvas();
                    saveStateForUndo("배경 이미지 변경");
                };
            };
            reader.readAsDataURL(file);
        }

        function handleImageUpload(e, type, index = -1) {
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);
            if (!cut) return;
            const files = e.target.files;
            if (!files || files.length === 0) return;

            if (type === 'mouthImgs') {
                const isException = dom.applyMouthOnlyCurrentCheckbox.checked;
                let filesLoaded = 0;
                let allFilesProcessed = false;

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const targetIndex = index + i;
                    if (targetIndex >= 7) break;

                    const reader = new FileReader();
                    reader.onload = ((theFile, theIndex) => {
                        return (event) => {
                            const imgStore = cut.mouthImgs[theIndex];
                            imgStore.img.src = event.target.result;
                            imgStore.fileName = theFile.name;
                            imgStore.img.onload = () => {
                                filesLoaded++;
                                if (filesLoaded === files.length && !allFilesProcessed) {
                                    allFilesProcessed = true; // 중복 실행 방지
                                    if (!isException) {
                                        updateAndApplyDefaultMouths(cut);
                                    } else {
                                        saveStateForUndo("입모양 개별 적용");
                                    }
                                }
                                updateEditorUI();
                                drawInitialCanvas();
                                checkAllFilesReady();
                            };
                        };
                    })(file, targetIndex);
                    reader.readAsDataURL(file);
                }
            }
            e.target.value = null;
        }

        function handleCharacterSlider(e) {
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);
            if (!cut) return;
            cut.characterScale = e.target.value / 100;
            dom.characterSizeValue.textContent = e.target.value;
            if (!state.isAnimating) {
                drawInitialCanvas();
            }
        }

        function handleMouthSlider(e) {
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);
            if (!cut) return;
            cut.mouthSize = e.target.value / 100;
            dom.mouthSizeValue.textContent = e.target.value;
            if (!state.isAnimating) drawInitialCanvas();
        }
        
        function handlePlaybackSeek(e) {
            if (!state.audioFile) return;
            if (e.type === 'touchstart') e.preventDefault();
            const E = unify(e);

            const timelineRect = dom.playbackTimelineContainer.getBoundingClientRect();
            const interactiveWidth = dom.playbackTimelineContainer.offsetWidth;
            
            const seek = (evt) => {
                const P = unify(evt);
                const mouseX = P.clientX - timelineRect.left;
                const progress = Math.max(0, Math.min(1, mouseX / interactiveWidth));
                const newTime = progress * state.audioDuration;
                if (state.audioElement) {
                    state.audioElement.currentTime = newTime;
                }
                updatePlaybackTime(newTime, state.audioDuration);
                if (!state.isAnimating) {
                    updateCanvasForTime(newTime);
                }
            };
            
            seek(e);

            const onMove = (moveEvent) => {
                seek(moveEvent);
            };

            const onEnd = () => {
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('mouseup', onEnd);
                window.removeEventListener('touchmove', onMove);
                window.removeEventListener('touchend', onEnd);
            };

            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onEnd);
            window.addEventListener('touchmove', onMove, { passive: true });
            window.addEventListener('touchend', onEnd);
        }
        
        let initialPinchDistance = null;
        function handleCutEditing(e) {
            if (e.type === 'touchstart') e.preventDefault();
            if (!state.audioFile) return;

            // Pan and Zoom logic for Touch
            if (e.touches) {
                if (e.touches.length === 2) {
                    initialPinchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                } else if (e.touches.length === 1 && !e.target.closest('.layer-container')) {
                    state.isPanning = true;
                    state.lastPanX = e.touches[0].clientX;
                }
            }

            const E = unify(e);

            const layerContainer = E.target.closest('.layer-container');
            if (!layerContainer) return;

            const layerId = parseFloat(layerContainer.dataset.layerId);
            const timelineRect = layerContainer.getBoundingClientRect();
            const startX = E.clientX;
            const clickPx = startX - timelineRect.left;
            const clickTime = pxToTime(clickPx);
            
            const targetEl = E.target;
            const cutBar = targetEl.closest('.timeline-cut-bar');

            if (cutBar) {
                const cutId = parseFloat(cutBar.dataset.id);
                const cut = state.cuts.find(c => c.id === cutId);
                if (!cut) return;

                // Selection Logic
                if (state.isMultiSelectMode) {
                    if(e.type === 'mousedown' || e.type === 'touchstart') {
                         if (state.selectedCutIds.includes(cutId)) {
                            state.selectedCutIds = state.selectedCutIds.filter(id => id !== cutId);
                        } else {
                            state.selectedCutIds.push(cutId);
                        }
                        state.lastSelectedCutId = cutId;
                        renderTimeline();
                        updateEditorUI();
                    }
                    return; // No dragging/resizing in multi-select mode for simplicity
                } else {
                    state.selectedCutIds = [cutId];
                    state.lastSelectedCutId = cutId;
                }

                const isHandle = targetEl.classList.contains('timeline-handle');
                if (!isHandle && (e.type === 'mousedown' || e.type === 'touchstart')) {
                     if (state.audioElement) state.audioElement.currentTime = cut.startTime;
                    updatePlaybackTime(cut.startTime, state.audioDuration);
                    updateCanvasForTime(cut.startTime);
                }
                
                renderTimeline();
                updateEditorUI();
                drawInitialCanvas();

                // Cut Drag, Resize, Swap Logic
                const isStartHandle = targetEl.classList.contains('start');
                const isEndHandle = targetEl.classList.contains('end');
                const initialStartTime = cut.startTime;
                const initialEndTime = cut.endTime;
                const initialStartPx = timeToPx(initialStartTime);
                
                const onMove = (moveEvent) => {
                    const MOVE_E = unify(moveEvent);
                    let deltaX = MOVE_E.clientX - startX;
                    if (moveEvent.shiftKey) deltaX /= 4;
                    
                    if (isStartHandle) {
                        let newStartTime = pxToTime(initialStartPx + deltaX);
                        newStartTime = findSnapPoint(newStartTime, cutId);
                        if (newStartTime < cut.endTime - 0.1) cut.startTime = newStartTime;
                    } else if (isEndHandle) {
                        let newEndTime = pxToTime(timeToPx(initialEndTime) + deltaX);
                        newEndTime = findSnapPoint(newEndTime, cutId);
                        if (newEndTime > cut.startTime + 0.1) cut.endTime = newEndTime;
                    } else { // Move or Swap
                        cutBar.classList.add('dragging');
                        const newStartPx = initialStartPx + deltaX;
                        let newStartTime = pxToTime(newStartPx);
                        const duration = initialEndTime - initialStartTime;
                        
                        const snappedStartTime = findSnapPoint(newStartTime, cutId);
                        const snappedEndTime = findSnapPoint(newStartTime + duration, cutId);

                        if (Math.abs(snappedStartTime - newStartTime) < Math.abs(snappedEndTime - (newStartTime + duration))) {
                            newStartTime = snappedStartTime;
                        } else {
                            newStartTime = snappedEndTime - duration;
                        }
                        
                        if (newStartTime >= 0 && newStartTime + duration <= state.audioDuration) {
                            cut.startTime = newStartTime;
                            cut.endTime = newStartTime + duration;
                        }
                        
                        // Swap logic
                        const hoveredElement = document.elementFromPoint(MOVE_E.clientX, MOVE_E.clientY);
                        const targetBar = hoveredElement ? hoveredElement.closest('.timeline-cut-bar') : null;
                        
                        if (state.dropTargetCutForSwap && state.dropTargetCutForSwap !== targetBar) {
                            state.dropTargetCutForSwap.classList.remove('drag-over-swap');
                        }

                        if (targetBar && targetBar !== cutBar) {
                            targetBar.classList.add('drag-over-swap');
                            state.dropTargetCutForSwap = targetBar;
                        } else {
                            state.dropTargetCutForSwap = null;
                        }
                    }
                    renderTimeline();
                };

                const onEnd = () => {
                    cutBar.classList.remove('dragging');
                    dom.snapIndicator.style.display = 'none';
                    window.removeEventListener('mousemove', onMove);
                    window.removeEventListener('mouseup', onEnd);
                    window.removeEventListener('touchmove', onMove);
                    window.removeEventListener('touchend', onEnd);
                    
                    if (state.dropTargetCutForSwap) {
                        const targetId = parseFloat(state.dropTargetCutForSwap.dataset.id);
                        const targetCut = state.cuts.find(c => c.id === targetId);
                        if (targetCut && targetCut.layerId === cut.layerId) {
                            swapCutContents(cut, targetCut);
                        }
                        state.dropTargetCutForSwap.classList.remove('drag-over-swap');
                        state.dropTargetCutForSwap = null;
                    }
                    saveStateForUndo("컷 편집");
                };

                window.addEventListener('mousemove', onMove);
                window.addEventListener('mouseup', onEnd);
                window.addEventListener('touchmove', onMove, { passive: true });
                window.addEventListener('touchend', onEnd);
                return;
            }

            // New cut creation
            let dragged = false;
            const isInsideAnotherCut = state.cuts.some(c => c.layerId === layerId && clickTime > c.startTime && clickTime < c.endTime);
            if (isInsideAnotherCut) return;

            const initialClickTime = pxToTime(E.clientX - timelineRect.left);
            const tempCutBar = document.createElement('div');
            tempCutBar.className = 'timeline-cut-bar active';
            tempCutBar.style.position = 'absolute';
            tempCutBar.style.height = '100%';
            tempCutBar.style.width = '0px';
            layerContainer.querySelector('.relative.w-full.h-full').appendChild(tempCutBar);

            const onMove = (moveEvent) => {
                dragged = true;
                const MOVE_E = unify(moveEvent);
                const currentMouseTime = pxToTime(MOVE_E.clientX - timelineRect.left);
                let startTime = Math.min(initialClickTime, currentMouseTime);
                let endTime = Math.max(initialClickTime, currentMouseTime);
                const nextCut = state.cuts.filter(c => c.layerId === layerId && c.startTime > startTime).sort((a, b) => a.startTime - b.startTime)[0];
                if (nextCut && endTime > nextCut.startTime) endTime = nextCut.startTime;
                tempCutBar.style.left = `${timeToPx(startTime)}px`;
                tempCutBar.style.width = `${timeToPx(endTime) - timeToPx(startTime)}px`;
            };

            const onEnd = (upEvent) => {
                dom.snapIndicator.style.display = 'none';
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('mouseup', onEnd);
                window.removeEventListener('touchmove', onMove);
                window.removeEventListener('touchend', onEnd);
                tempCutBar.remove();

                if (dragged) {
                    const UP_E = unify(upEvent);
                    const finalMouseTime = pxToTime(UP_E.clientX - timelineRect.left);
                    let startTime = Math.min(initialClickTime, finalMouseTime);
                    let endTime = Math.max(initialClickTime, finalMouseTime);
                    startTime = findSnapPoint(startTime, null);
                    endTime = findSnapPoint(endTime, null);
                    const nextCut = state.cuts.filter(c => c.layerId === layerId && c.startTime > startTime).sort((a, b) => a.startTime - b.startTime)[0];
                    if (nextCut && endTime > nextCut.startTime) endTime = nextCut.startTime;
                    if (Math.abs(timeToPx(endTime) - timeToPx(startTime)) > 5) {
                        addNewCut(startTime, endTime, layerId);
                    }
                }
            };

            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onEnd);
            window.addEventListener('touchmove', onMove, { passive: true });
            window.addEventListener('touchend', onEnd);
        }


        function swapCutContents(cutA, cutB) {
            const propsToSwap = [
                'characterImg', 'mouthImgs', 'backgroundImage', 'backgroundFit',
                'mouthX', 'mouthY', 'mouthSize', 'mouthRotation',
                'characterScale', 'characterOffsetX', 'characterOffsetY', 'rotation',
                'isCharacterLocked'
            ];

            propsToSwap.forEach(prop => {
                [cutA[prop], cutB[prop]] = [cutB[prop], cutA[prop]];
            });
            
            showNotification(`컷의 내용을 바꿨습니다.`);
            renderTimeline();
            updateEditorUI();
            drawInitialCanvas();
            saveStateForUndo("컷 내용 교체");
        }

        function findSnapPoint(time, excludeCutId) {
            const snapThresholdPx = 10;
            const snapThresholdTime = pxToTime(state.timelinePan + snapThresholdPx) - pxToTime(state.timelinePan);

            const snapPoints = [0, state.audioDuration];
            state.cuts.forEach(cut => {
                if (cut.id !== excludeCutId) {
                    snapPoints.push(cut.startTime, cut.endTime);
                }
            });

            let bestSnap = null;
            let minDistance = snapThresholdTime;

            for (const point of snapPoints) {
                const distance = Math.abs(time - point);
                if (distance < minDistance) {
                    minDistance = distance;
                    bestSnap = point;
                }
            }
            
            if (bestSnap !== null) {
                const snapPx = timeToPx(bestSnap);
                dom.snapIndicator.style.left = `${snapPx}px`;
                dom.snapIndicator.style.display = 'block';
                return bestSnap;
            } else {
                dom.snapIndicator.style.display = 'none';
                return time;
            }
        }

        function updateCanvasForTime(time) {
            const activeCuts = state.cuts.filter(cut => time >= cut.startTime && time < cut.endTime);
            state.currentlyDisplayedCutIds = activeCuts.map(c => c.id);
            const mouthMap = new Map(activeCuts.map(c => [c.id, c.mouthImgs[0]?.img]));
            drawScene(activeCuts, mouthMap);
        }

        function handleAnimateClick() {
            if (!state.audioFile || dom.animateBtn.disabled) return;
            if (state.isAnimating) stopAnimation();
            else startAnimation();
        }

        function startAnimation() {
            if (!state.cuts.some(c => c.characterImg.src) || !state.audioFile) {
                showNotification('오디오 파일과 캐릭터 이미지가 있는 컷이 하나 이상 필요합니다.', true);
                return;
            }
            state.isAnimating = true;
            dom.animateBtn.textContent = '■ 애니메이션 정지';
            dom.mouthMarker.classList.add('hidden');
            dom.transformHandlesContainer.innerHTML = '';

            if (!state.analyser) {
                state.analyser = GLOBAL_AUDIO_CONTEXT.createAnalyser();
                state.analyser.fftSize = 4096;
                state.analyser.smoothingTimeConstant = 0.5;
                state.frequencyData = new Uint8Array(state.analyser.frequencyBinCount);
            }
            if (!state.audioElement) {
                state.audioElement = new Audio();
                state.source = GLOBAL_AUDIO_CONTEXT.createMediaElementSource(state.audioElement);
                state.source.connect(state.analyser);
                state.analyser.connect(GLOBAL_AUDIO_CONTEXT.destination);
                state.audioElement.onended = stopAnimation;
            }
            
            if (!state.audioElement.src || state.audioElement.src.startsWith('blob:') === false) {
                 state.audioElement.src = URL.createObjectURL(state.audioFile);
            }
            
            GLOBAL_AUDIO_CONTEXT.resume();
            state.audioElement.play().catch(e => console.error("오디오 재생 오류:", e));
            
            animateLoop();
        }

        function stopAnimation() {
            state.isAnimating = false;
            if (state.audioElement) state.audioElement.pause();
            cancelAnimationFrame(state.animationFrameId);
            dom.animateBtn.textContent = '▶︎ 애니메이션 시작';
            updateCanvasForTime(state.audioElement ? state.audioElement.currentTime : 0);
        }

        function animateLoop() {
            if (!state.isAnimating) return;
            state.animationFrameId = requestAnimationFrame(animateLoop);

            const currentTime = state.audioElement.currentTime;
            if (!state.isDraggingPlayhead) {
                updatePlaybackTime(currentTime, state.audioDuration);
            }

            const activeCuts = state.cuts.filter(cut => currentTime >= cut.startTime && currentTime < cut.endTime);
            state.currentlyDisplayedCutIds = activeCuts.map(c => c.id);

            if (activeCuts.length === 0) {
                drawScene([]);
                return;
            }
            
            const mouthMap = new Map();
            activeCuts.forEach(cut => {
                const mouthIndex = (state.mode === 'volume') ? getVolumeMouthIndex() : getVowelMouthIndex();
                mouthMap.set(cut.id, cut.mouthImgs[mouthIndex]?.img);
            });

            drawScene(activeCuts, mouthMap);
        }

        function getVolumeMouthIndex() {
            state.analyser.getByteFrequencyData(state.frequencyData);
            const averageVolume = state.frequencyData.reduce((s, v) => s + v, 0) / state.frequencyData.length;
            if (averageVolume > 50) return 6;
            if (averageVolume > 35) return 5;
            if (averageVolume > 25) return 4;
            if (averageVolume > 15) return 3;
            if (averageVolume > 8) return 2;
            if (averageVolume > 3) return 1;
            return 0;
        }

        function getVowelMouthIndex() {
            state.analyser.getByteFrequencyData(state.frequencyData);
            const freqData = state.frequencyData;
            const sampleRate = GLOBAL_AUDIO_CONTEXT.sampleRate;
            const fftSize = state.analyser.fftSize;

            const getEnergy = (startFreq, endFreq) => {
                const startIndex = Math.round(startFreq / (sampleRate / fftSize));
                const endIndex = Math.round(endFreq / (sampleRate / fftSize));
                let sum = 0;
                for (let i = startIndex; i <= endIndex; i++) {
                    sum += freqData[i];
                }
                return sum / (endIndex - startIndex + 1);
            };

            if (getEnergy(100, 8000) < 8) return 0;
            if (getEnergy(4000, 10000) > 25) return 2;

            const getWeightedAvgFreq = (startFreq, endFreq) => {
                const startIndex = Math.round(startFreq / (sampleRate / fftSize));
                const endIndex = Math.round(endFreq / (sampleRate / fftSize));
                let weightedSum = 0, totalWeight = 0;
                for (let i = startIndex; i <= endIndex; i++) {
                    const freq = i * (sampleRate / fftSize);
                    weightedSum += freq * freqData[i];
                    totalWeight += freqData[i];
                }
                return totalWeight === 0 ? 0 : weightedSum / totalWeight;
            };

            const f1 = getWeightedAvgFreq(250, 1000);
            const f2 = getWeightedAvgFreq(1000, 3000);
            if (getEnergy(250, 1000) > 30) {
                if (f1 > 650) return 5; // 아
                if (f1 < 450 && f2 < 1500) return 6; // 오/우
                if (f1 < 400 && f2 > 2000) return 3; // 이
                if (f1 >= 400 && f1 <= 650 && f2 > 1600) return 4; // 에
            }
            return 1;
        }

        let notificationTimeout;
        function showNotification(message, isError = false) {
            clearTimeout(notificationTimeout);
            dom.notification.textContent = message;
            dom.notification.classList.toggle('bg-red-600', isError);
            dom.notification.classList.toggle('bg-gray-800', !isError);
            dom.notification.classList.remove('opacity-0');

            notificationTimeout = setTimeout(() => {
                dom.notification.classList.add('opacity-0');
            }, 3000);
        }

        function setupDropZones() {
            const zones = {
                'audio-drop-zone': 'audio-upload',
                'bg-drop-zone': 'bg-upload',
                'project-drop-zone': 'load-project-upload',
            };
            for (const zoneId in zones) {
                const zone = document.getElementById(zoneId);
                const input = document.getElementById(zones[zoneId]);
                zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('drag-over'); });
                zone.addEventListener('dragleave', e => { e.preventDefault(); zone.classList.remove('drag-over'); });
                zone.addEventListener('drop', e => {
                    e.preventDefault();
                    zone.classList.remove('drag-over');
                    if (e.dataTransfer.files.length > 0) {
                        input.files = e.dataTransfer.files;
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });
            }
        }
        
        function handleKeydown(e) {
            if (e.target.isContentEditable || ['INPUT', 'SELECT', 'TEXTAREA'].includes(e.target.tagName)) {
                return;
            }

            // Undo/Redo
            if (e.ctrlKey || e.metaKey) {
                if (e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) redo();
                    else undo();
                    return;
                }
                if (e.key.toLowerCase() === 'y') {
                    e.preventDefault();
                    redo();
                    return;
                }
            }

            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const lastSelectedCut = state.cuts.find(c => c.id === lastSelectedId);
            
            if (lastSelectedCut && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                const moveStep = e.shiftKey ? 0.02 : 0.005; 
                switch (e.key) {
                    case 'ArrowUp': lastSelectedCut.mouthY -= moveStep; break;
                    case 'ArrowDown': lastSelectedCut.mouthY += moveStep; break;
                    case 'ArrowLeft': lastSelectedCut.mouthX -= moveStep; break;
                    case 'ArrowRight': lastSelectedCut.mouthX += moveStep; break;
                }
                lastSelectedCut.mouthX = Math.max(0, Math.min(1, lastSelectedCut.mouthX));
                lastSelectedCut.mouthY = Math.max(0, Math.min(1, lastSelectedCut.mouthY));
                if (!state.isAnimating) drawInitialCanvas();
                clearTimeout(window.arrowKeyTimeout);
                window.arrowKeyTimeout = setTimeout(() => saveStateForUndo("입 위치 미세조정"), 500);
                return;
            }

            let handled = false;
            switch (e.key.toLowerCase()) {
                case ' ':
                    handleAnimateClick();
                    handled = true;
                    break;
                case 'delete': case 'backspace':
                    if (state.selectedCutIds.length > 0) {
                        deleteSelectedCuts();
                        handled = true;
                    }
                    break;
                case 'k':
                    applyMagnetToActiveLayer();
                    handled = true;
                    break;
            }
            if (handled) e.preventDefault();
        }
        
        function updateLockUI(cut) {
            if (!cut) return;
            if (cut.isCharacterLocked) {
                dom.lockIcon.classList.remove('hidden');
                dom.unlockIcon.classList.add('hidden');
                dom.toggleLockBtn.classList.remove('text-green-500');
                dom.toggleLockBtn.classList.add('text-gray-500');
                dom.toggleLockBtn.title = '입 위치/크기 편집 모드 (캐릭터 잠김)';
                dom.canvas.style.cursor = 'default';
            } else {
                dom.lockIcon.classList.add('hidden');
                dom.unlockIcon.classList.remove('hidden');
                dom.toggleLockBtn.classList.remove('text-gray-500');
                dom.toggleLockBtn.classList.add('text-green-500');
                dom.toggleLockBtn.title = '캐릭터 이동/회전 편집 모드 (잠금 해제)';
                dom.canvas.style.cursor = 'grab';
            }
        }

        function handleToggleLock() {
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);
            if (!cut) return;
            cut.isCharacterLocked = !cut.isCharacterLocked;
            updateLockUI(cut);
            saveStateForUndo("캐릭터 잠금 변경");
        }

        function updateAndApplyDefaultMouths(sourceCut) {
            state.defaultMouthImgs = sourceCut.mouthImgs.map(sourceImgData => ({
                src: sourceImgData.img.src,
                fileName: sourceImgData.fileName
            }));

            state.cuts.forEach(targetCut => {
                targetCut.mouthImgs = state.defaultMouthImgs.map(defaultImgData => {
                    const newImg = new Image();
                    if (defaultImgData.src) {
                        newImg.src = defaultImgData.src;
                    }
                    return { img: newImg, fileName: defaultImgData.fileName };
                });
            });
            showNotification('기본 입 모양이 설정되어 모든 컷에 적용되었습니다.');
            saveStateForUndo("기본 입모양 적용");
            renderTimeline();
        }

        function handleApplyMouthsToAll() {
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const selectedCut = state.cuts.find(c => c.id === lastSelectedId);
            if (!selectedCut) {
                showNotification('먼저 컷을 선택해주세요.', true);
                return;
            }
            const hasAllMouths = selectedCut.mouthImgs.every(imgData => imgData.img.src);
            if (!hasAllMouths) {
                showNotification('현재 컷의 입 모양 이미지 7개가 모두 등록되어야 합니다.', true);
                return;
            }
            updateAndApplyDefaultMouths(selectedCut);
        }

        function handleApplyBgToAll() {
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const selectedCut = state.cuts.find(c => c.id === lastSelectedId);
            if (!selectedCut || !selectedCut.backgroundImage.src) {
                showNotification('배경을 적용할 컷을 먼저 선택하고 배경 이미지를 등록해주세요.', true);
                return;
            }

            state.cuts.forEach(cut => {
                if (cut.id !== lastSelectedId) {
                    cut.backgroundImage = new Image();
                    cut.backgroundImage.src = selectedCut.backgroundImage.src;
                    cut.backgroundImage.fileName = selectedCut.backgroundImage.fileName;
                    cut.backgroundFit = selectedCut.backgroundFit;
                }
            });
            showNotification('모든 컷에 배경을 적용했습니다.');
            saveStateForUndo("모든 컷에 배경 적용");
            drawInitialCanvas();
        }

        function handleCanvasDragOver(e) {
            e.preventDefault();
            if (state.selectedCutIds.length > 0 && !state.activeTransform) {
                dom.canvasDropOverlay.classList.add('flex');
                 dom.canvasDropOverlay.classList.remove('hidden');
            }
        }

        function handleCanvasDragLeave(e) {
            e.preventDefault();
            dom.canvasDropOverlay.classList.add('hidden');
            dom.canvasDropOverlay.classList.remove('flex');
        }

        function handleCanvasDrop(e) {
            e.preventDefault();
            handleCanvasDragLeave(e);
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);
            if (cut && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                processCharacterImage(file, cut);
            }
        }
        
        // --- Undo/Redo Functions ---
        function saveStateForUndo(actionName) {
            // console.log("Saving state for:", actionName); // 디버깅용
            state.redoStack = []; // 새로운 작업이 생기면 redo 스택은 비워짐
            const stateSnapshot = deepCopyState();
            state.undoStack.push(stateSnapshot);
            if (state.undoStack.length > 50) { // 스택 크기 제한
                state.undoStack.shift();
            }
            updateUndoRedoButtons();
        }

        function undo() {
            if (state.undoStack.length === 0) return;
            const currentState = deepCopyState();
            state.redoStack.push(currentState);
            
            const prevState = state.undoStack.pop();
            restoreState(prevState);
            updateUndoRedoButtons();
        }

        function redo() {
            if (state.redoStack.length === 0) return;
            const currentState = deepCopyState();
            state.undoStack.push(currentState);

            const nextState = state.redoStack.pop();
            restoreState(nextState);
            updateUndoRedoButtons();
        }

        async function restoreState(newStateData) {
            const imageLoadPromises = [];

            const cuts = newStateData.cuts.map(cutData => {
                const newCut = { ...cutData };
                newCut.characterImg = new Image();
                if (cutData.characterImg.src) {
                    imageLoadPromises.push(new Promise(resolve => {
                        newCut.characterImg.onload = resolve;
                        newCut.characterImg.onerror = resolve; // 에러가 나도 진행
                        newCut.characterImg.src = cutData.characterImg.src;
                    }));
                    newCut.characterImg.fileName = cutData.characterImg.fileName;
                }
                newCut.backgroundImage = new Image();
                if (cutData.backgroundImage.src) {
                    imageLoadPromises.push(new Promise(resolve => {
                        newCut.backgroundImage.onload = resolve;
                        newCut.backgroundImage.onerror = resolve;
                        newCut.backgroundImage.src = cutData.backgroundImage.src;
                    }));
                    newCut.backgroundImage.fileName = cutData.backgroundImage.fileName;
                }
                newCut.mouthImgs = cutData.mouthImgs.map(imgData => {
                    const newImg = new Image();
                    if (imgData.src) {
                        imageLoadPromises.push(new Promise(resolve => {
                            newImg.onload = resolve;
                            newImg.onerror = resolve;
                            newImg.src = imgData.src;
                        }));
                    }
                    return { img: newImg, fileName: imgData.fileName };
                });
                return newCut;
            });
            
            state.layers = newStateData.layers;
            state.activeLayerIndex = newStateData.activeLayerIndex;
            state.cuts = cuts;

            await Promise.all(imageLoadPromises);
            
            renderLayerList();
            renderTimeline();
            updateEditorUI();
            drawInitialCanvas();
            checkAllFilesReady();
        }


        function deepCopyState() {
            return {
                cuts: state.cuts.map(cut => ({
                    ...cut,
                    characterImg: { src: cut.characterImg.src, fileName: cut.characterImg.fileName },
                    backgroundImage: { src: cut.backgroundImage.src, fileName: cut.backgroundImage.fileName },
                    mouthImgs: cut.mouthImgs.map(imgData => ({ src: imgData.img.src, fileName: imgData.fileName })),
                })),
                layers: JSON.parse(JSON.stringify(state.layers)),
                activeLayerIndex: state.activeLayerIndex,
            };
        }

        function updateUndoRedoButtons() {
            dom.undoBtn.disabled = state.undoStack.length === 0;
            dom.redoBtn.disabled = state.redoStack.length === 0;
            dom.undoBtn.classList.toggle('text-gray-400', dom.undoBtn.disabled);
            dom.redoBtn.classList.toggle('text-gray-400', dom.redoBtn.disabled);
        }

        // --- Project Save/Load Functions ---
        async function saveProject() {
            const zip = new JSZip();
            const mediaFolder = zip.folder("media");
            const filesToSave = new Map();

            // Collect all unique files
            if (state.audioFile) filesToSave.set(state.audioFileName, state.audioFile);
            state.cuts.forEach(cut => {
                if (cut.characterImg.src && cut.characterImg.fileName) filesToSave.set(cut.characterImg.fileName, cut.characterImg.src);
                if (cut.backgroundImage.src && cut.backgroundImage.fileName) filesToSave.set(cut.backgroundImage.fileName, cut.backgroundImage.src);
                cut.mouthImgs.forEach(imgData => {
                    if (imgData.img.src && imgData.fileName) filesToSave.set(imgData.fileName, imgData.img.src);
                });
            });

            // Add files to zip
            for (const [name, content] of filesToSave.entries()) {
                if (typeof content === 'string') { // Data URL
                    mediaFolder.file(name, content.split(',')[1], { base64: true });
                } else { // File object
                    mediaFolder.file(name, content);
                }
            }

            const projectData = {
                version: "2.1", // 버전 업데이트
                audioFileName: state.audioFileName,
                audioDuration: state.audioDuration,
                mode: state.mode,
                cuts: deepCopyState().cuts, // deepCopyState를 사용해 이미지 객체 제외
                layers: state.layers,
                activeLayerIndex: state.activeLayerIndex,
                isHandDrawnEffect: state.isHandDrawnEffect,
                handDrawnIntensity: state.handDrawnIntensity,
            };
            zip.file("project.liproject", JSON.stringify(projectData, null, 2));

            // Generate and download zip
            const zipBlob = await zip.generateAsync({ type: "blob" });
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[-T:]/g, "");
            const a = document.createElement("a");
            a.href = URL.createObjectURL(zipBlob);
            a.download = `liproject_${timestamp}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
            showNotification('프로젝트가 ZIP 파일로 저장되었습니다.');
        }

        function handleProjectLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const zip = await JSZip.loadAsync(event.target.result);
                    const projectFile = zip.file("project.liproject");
                    if (!projectFile) {
                        throw new Error("project.liproject 파일을 찾을 수 없습니다.");
                    }
                    const projectData = JSON.parse(await projectFile.async("string"));
                    
                    const fileMap = new Map();
                    const mediaFolder = zip.folder("media");
                    const filePromises = [];
                    mediaFolder.forEach((relativePath, zipEntry) => {
                        const promise = zipEntry.async("blob").then(blob => {
                            fileMap.set(relativePath, new File([blob], relativePath, { type: blob.type }));
                        });
                        filePromises.push(promise);
                    });
                    
                    await Promise.all(filePromises);
                    loadProjectData(projectData, fileMap);

                } catch (err) {
                    console.error("프로젝트 파일 로딩 오류:", err);
                    showNotification("유효하지 않은 프로젝트 파일(ZIP)입니다.", true);
                }
            };
            reader.readAsArrayBuffer(file);
            e.target.value = null;
        }

        async function loadProjectData(projectData, fileMap) {
            // --- Reset audio state before loading ---
            if (state.isAnimating) stopAnimation();
            if (state.audioElement && state.audioElement.src) URL.revokeObjectURL(state.audioElement.src);
            state.audioElement = null;
            state.source = null;
            // --- END OF RESET ---

            // 1. 오디오 로드
            if (projectData.audioFileName) {
                const audioFile = fileMap.get(projectData.audioFileName);
                if (audioFile) {
                    state.audioFile = audioFile;
                    state.audioFileName = audioFile.name;
                    dom.audioFilename.textContent = audioFile.name;
                    
                    dom.audioLoadingStatus.textContent = "오디오 분석 중...";
                    dom.audioLoadingStatus.classList.remove('hidden');
                    try {
                        const arrayBuffer = await audioFile.arrayBuffer();
                        const audioBuffer = await GLOBAL_AUDIO_CONTEXT.decodeAudioData(arrayBuffer);
                        state.audioDuration = audioBuffer.duration;
                        state.audioBuffer = audioBuffer;
                        state.audioPeakData = analyzeAudio(audioBuffer);
                    } catch (err) {
                        console.error("불러온 오디오 파일 분석 오류:", err);
                        showNotification("오디오 파일을 분석하는 데 실패했습니다.", true);
                    } finally {
                        dom.audioLoadingStatus.classList.add('hidden');
                    }
                }
            } else {
                 state.audioFile = null;
                 state.audioFileName = '';
                 state.audioDuration = projectData.audioDuration || 0;
                 state.audioPeakData = [];
            }

            // 2. 컷 데이터 로드
            const loadedCuts = [];
            const fileLoadPromises = [];

            projectData.cuts.forEach(cutData => {
                const newCut = { ...cutData };
                newCut.characterImg = new Image();
                newCut.backgroundImage = new Image();
                newCut.mouthImgs = Array.from({length: 7}, () => ({ img: new Image(), fileName: null }));

                const loadImage = (imgObj, fileName, imgDataObj) => {
                    const file = fileMap.get(fileName);
                    if (file) {
                        const promise = new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                imgObj.src = e.target.result;
                                imgDataObj.fileName = fileName; // fileName 저장
                                imgObj.onload = resolve;
                                imgObj.onerror = resolve;
                            };
                            reader.readAsDataURL(file);
                        });
                        fileLoadPromises.push(promise);
                    }
                };

                if (cutData.characterImg.fileName) loadImage(newCut.characterImg, cutData.characterImg.fileName, newCut.characterImg);
                if (cutData.backgroundImage.fileName) loadImage(newCut.backgroundImage, cutData.backgroundImage.fileName, newCut.backgroundImage);
                cutData.mouthImgs.forEach((imgData, index) => {
                    if (imgData.fileName) loadImage(newCut.mouthImgs[index].img, imgData.fileName, newCut.mouthImgs[index]);
                });
                loadedCuts.push(newCut);
            });

            await Promise.all(fileLoadPromises);

            state.cuts = loadedCuts;
            state.mode = projectData.mode || 'volume';
            dom.modeSelect.value = state.mode;
            
            // 레이어 로드 (하위 호환성)
            if (projectData.layers) {
                state.layers = projectData.layers;
                state.activeLayerIndex = projectData.activeLayerIndex || 0;
            } else {
                state.layers = [{ id: Date.now(), name: "레이어 1" }];
                state.activeLayerIndex = 0;
                state.cuts.forEach(c => c.layerId = state.layers[0].id);
            }

            state.isHandDrawnEffect = projectData.isHandDrawnEffect !== false;
            state.handDrawnIntensity = projectData.handDrawnIntensity || 5;
            dom.handDrawnToggle.checked = state.isHandDrawnEffect;
            dom.handDrawnIntensitySlider.value = state.handDrawnIntensity;
            dom.handDrawnIntensityValue.textContent = state.handDrawnIntensity;
            updateHandDrawnEffect();
            
            // 3. UI 업데이트
            state.selectedCutIds = [];
            state.lastSelectedCutId = null;
            state.undoStack = [];
            state.redoStack = [];
            updateUndoRedoButtons();
            renderLayerList();
            renderTimeline();
            updateEditorUI();
            drawInitialCanvas();
            showNotification('프로젝트를 불러왔습니다.');
            checkAllFilesReady();
        }

        // --- Waveform Functions ---
        function analyzeAudio(audioBuffer) {
            const rawData = audioBuffer.getChannelData(0);
            const samples = 2000;
            const blockSize = Math.floor(rawData.length / samples);
            const peaks = [];
            for (let i = 0; i < samples; i++) {
                const blockStart = blockSize * i;
                let sum = 0;
                for (let j = 0; j < blockSize; j++) {
                    sum += Math.abs(rawData[blockStart + j]);
                }
                peaks.push(sum / blockSize);
            }
            const max = Math.max(...peaks);
            return peaks.map(p => p / max);
        }

        function drawWaveform(canvas, progressCanvas) {
            if (state.audioPeakData.length === 0) return;
            const ctx = canvas.getContext('2d');
            const parent = canvas.parentElement.parentElement;
            
            canvas.width = parent.offsetWidth * state.timelineZoom;
            canvas.height = parent.offsetHeight;
            canvas.style.width = `${canvas.width}px`;
            canvas.style.left = `${-state.timelinePan}px`;
            
            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;

            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = '#d1d5db';
            ctx.lineWidth = 1;

            const step = width / state.audioPeakData.length;
            ctx.beginPath();
            for (let i = 0; i < state.audioPeakData.length; i++) {
                const x = i * step;
                const peak = state.audioPeakData[i] * centerY;
                ctx.moveTo(x, centerY - peak);
                ctx.lineTo(x, centerY + peak);
            }
            ctx.stroke();
        }

        function drawWaveformProgress() {
            if (state.audioPeakData.length === 0) return;
            const progressPx = timeToPx(state.audioElement ? state.audioElement.currentTime : 0) + state.timelinePan;
            
            document.querySelectorAll('.waveform-progress-canvas').forEach(canvas => {
                const ctx = canvas.getContext('2d');
                const parent = canvas.parentElement.parentElement;
                
                canvas.width = parent.offsetWidth * state.timelineZoom;
                canvas.height = parent.offsetHeight;
                canvas.style.width = `${canvas.width}px`;
                canvas.style.left = `${-state.timelinePan}px`;

                const width = canvas.width;
                const height = canvas.height;
                const centerY = height / 2;

                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;

                const step = width / state.audioPeakData.length;
                const endSampleIndex = Math.floor(progressPx / step);
                
                ctx.beginPath();
                for (let i = 0; i < endSampleIndex; i++) {
                    const x = i * step;
                    const peak = state.audioPeakData[i] * centerY;
                    ctx.moveTo(x, centerY - peak);
                    ctx.lineTo(x, centerY + peak);
                }
                ctx.stroke();
            });
        }

        // --- Export Functions ---
        function handleExportClick() {
             if (!state.audioFile || state.cuts.length === 0) {
                 showNotification("내보내기할 오디오와 컷이 필요합니다.", true);
                 return;
            }
            dom.exportModal.classList.remove('hidden');
            dom.exportModal.classList.add('flex');
            dom.exportProgressContainer.classList.add('hidden');
            dom.exportStartBtn.classList.remove('hidden');
            dom.exportDownloadBtn.classList.add('hidden');
            dom.exportStatusText.textContent = '';
            dom.exportProgressBar.style.width = '0%';
        }

        function closeExportModal() {
            dom.exportModal.classList.add('hidden');
            dom.exportModal.classList.remove('flex');
        }

        async function startExport() {
            dom.exportStartBtn.classList.add('hidden');
            dom.exportProgressContainer.classList.remove('hidden');
            dom.exportStatusText.textContent = '렌더링 준비 중...';

            const quality = parseInt(dom.exportQualitySelect.value, 10);
            const frameRate = 30;
            const exportSelection = dom.exportSelectionCheckbox.checked;

            let renderStartTime = 0;
            let renderDuration = state.audioDuration;

            if (exportSelection) {
                if (state.selectedCutIds.length === 0) {
                    showNotification("내보낼 컷을 선택해주세요.", true);
                    closeExportModal();
                    return;
                }
                const selectedCuts = state.cuts.filter(c => state.selectedCutIds.includes(c.id));
                renderStartTime = Math.min(...selectedCuts.map(c => c.startTime));
                renderDuration = Math.max(...selectedCuts.map(c => c.endTime)) - renderStartTime;
            }

            if (renderDuration <= 0) {
                showNotification("내보낼 영상의 길이가 0초입니다.", true);
                closeExportModal();
                return;
            }
            
            const firstCutWithChar = state.cuts.find(c => c.characterImg.src);
            if (!firstCutWithChar) {
                showNotification("캐릭터 이미지가 있는 컷이 하나 이상 필요합니다.", true);
                closeExportModal();
                return;
            }
            
            const aspect = firstCutWithChar.characterImg.naturalWidth / firstCutWithChar.characterImg.naturalHeight;
            const exportWidth = quality === 1080 ? 1920 : (quality === 720 ? 1280 : 640);
            const exportHeight = Math.round(exportWidth / aspect);

            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportWidth;
            exportCanvas.height = exportHeight;
            const exportCtx = exportCanvas.getContext('2d');
            
            const videoStream = exportCanvas.captureStream(frameRate);
            const audioDestination = GLOBAL_AUDIO_CONTEXT.createMediaStreamDestination();
            const bufferSource = GLOBAL_AUDIO_CONTEXT.createBufferSource();
            bufferSource.buffer = state.audioBuffer;
            bufferSource.connect(audioDestination);

            const combinedStream = new MediaStream([
                ...videoStream.getVideoTracks(),
                ...audioDestination.stream.getAudioTracks()
            ]);
            
            const recorder = new MediaRecorder(combinedStream, { 
                mimeType: 'video/webm;codecs=vp9,opus',
                videoBitsPerSecond: quality * 1024 * 2,
                audioBitsPerSecond: 128000,
            });
            const chunks = [];

            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/mp4' }); // Use mp4 for better compatibility
                const url = URL.createObjectURL(blob);
                dom.exportDownloadLink.href = url;
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[-T:]/g, "");
                dom.exportDownloadLink.download = `liproject_video_${timestamp}.mp4`;
                dom.exportDownloadBtn.classList.remove('hidden');
                dom.exportStatusText.textContent = '렌더링 완료!';
                bufferSource.disconnect();
            };

            recorder.start();
            bufferSource.start(0, renderStartTime, renderDuration);

            const renderStartTimeMs = performance.now();

            function renderLoop() {
                const elapsedMs = performance.now() - renderStartTimeMs;
                const currentTime = renderStartTime + (elapsedMs / 1000);

                if (currentTime >= renderStartTime + renderDuration) {
                    renderFrameAtTime(renderStartTime + renderDuration);
                    if (recorder.state === 'recording') recorder.stop();
                    return;
                }

                renderFrameAtTime(currentTime);
                requestAnimationFrame(renderLoop);
            }

            function renderFrameAtTime(currentTime) {
                const progress = ((currentTime - renderStartTime) / renderDuration) * 100;
                dom.exportProgressBar.style.width = `${progress}%`;
                const frameCount = Math.floor((currentTime - renderStartTime) * frameRate);
                const totalFrames = Math.ceil(renderDuration * frameRate);
                dom.exportStatusText.textContent = `프레임 렌더링 중... ${frameCount} / ${totalFrames}`;

                exportCtx.filter = state.isHandDrawnEffect ? `url(#handDrawnFilter)` : 'none';
                exportCtx.clearRect(0, 0, exportWidth, exportHeight);
                
                const activeCuts = state.cuts
                    .filter(cut => currentTime >= cut.startTime && currentTime < cut.endTime)
                    .sort((a, b) => getLayerIndexFromId(a.layerId) - getLayerIndexFromId(b.layerId));

                if (activeCuts.length > 0) {
                    const peakIndex = Math.floor((currentTime / state.audioDuration) * state.audioPeakData.length);
                    const volume = state.audioPeakData[peakIndex] || 0;
                    let mouthIndex = 0;
                    if (volume > 0.5) mouthIndex = 6;
                    else if (volume > 0.35) mouthIndex = 5;
                    else if (volume > 0.25) mouthIndex = 4;
                    else if (volume > 0.15) mouthIndex = 3;
                    else if (volume > 0.08) mouthIndex = 2;
                    else if (volume > 0.03) mouthIndex = 1;
                    
                    activeCuts.forEach(activeCut => {
                        const mouthImg = activeCut.mouthImgs[mouthIndex]?.img;
                        drawBackground(activeCut, exportCanvas, exportCtx);
                        drawCharacter(activeCut, exportCanvas, exportCtx);
                        drawMouth(activeCut, mouthImg, exportCanvas, exportCtx);
                    });
                }
            }
            
            renderLoop();
        }

        // --- Hand drawn effect functions ---
        function startHandDrawnAnimation() {
            const turbulence = document.querySelector('#handDrawnFilter feTurbulence');
            if (!turbulence) return;
            
            setInterval(() => {
                if(state.isHandDrawnEffect) {
                    const seed = Math.floor(Math.random() * 1000);
                    turbulence.setAttribute('seed', seed);
                }
            }, 100);
        }

        function updateHandDrawnEffect() {
            state.isHandDrawnEffect = dom.handDrawnToggle.checked;
            dom.canvas.classList.toggle('hand-drawn', state.isHandDrawnEffect);
            dom.handDrawnIntensitySlider.disabled = !state.isHandDrawnEffect;
            
            if(state.isHandDrawnEffect) {
                state.handDrawnIntensity = dom.handDrawnIntensitySlider.value;
                dom.handDrawnIntensityValue.textContent = state.handDrawnIntensity;
                dom.displacementMap.setAttribute('scale', state.handDrawnIntensity);
            }
        }

        // --- Layer Functions ---
        function addLayer() {
            const newLayer = {
                id: Date.now() + Math.random(),
                name: `레이어 ${state.layers.length + 1}`
            };
            state.layers.push(newLayer);
            state.activeLayerIndex = state.layers.length - 1;
            renderLayerList();
            renderTimeline();
            saveStateForUndo("레이어 추가");
        }

        function setActiveLayer(index) {
            state.activeLayerIndex = index;
            renderLayerList();
        }
        
        function renderLayerList() {
            dom.layerList.innerHTML = '';

            state.layers.forEach((layer, index) => {
                const layerItem = document.createElement('div');
                layerItem.className = `layer-item p-2 rounded-md text-sm flex items-center justify-between group`;
                layerItem.dataset.index = index;
                layerItem.dataset.layerId = layer.id;

                if (index === state.activeLayerIndex) {
                    layerItem.classList.add('active');
                }

                const nameSpan = document.createElement('span');
                nameSpan.className = 'layer-name-span flex-grow mr-2';
                nameSpan.textContent = layer.name;
                
                const renameBtn = document.createElement('button');
                renameBtn.className = 'rename-layer-btn p-1 text-gray-400 hover:text-blue-500 hidden';
                renameBtn.innerHTML = `<svg class="w-4 h-4 pointer-events-none" fill="currentColor" viewBox="0 0 20 20"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z"></path><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd"></path></svg>`;
                
                if(index === state.activeLayerIndex) {
                    renameBtn.classList.remove('hidden', 'group-hover:flex');
                    renameBtn.classList.add('flex');
                } else {
                    renameBtn.classList.add('group-hover:flex');
                }
                
                layerItem.appendChild(nameSpan);
                layerItem.appendChild(renameBtn);
                dom.layerList.appendChild(layerItem);

                const startRename = () => {
                    nameSpan.contentEditable = true;
                    nameSpan.focus();
                    document.execCommand('selectAll', false, null);

                    const saveName = () => {
                        nameSpan.contentEditable = false;
                        const newName = nameSpan.textContent.trim();
                        if (newName && newName !== state.layers[index].name) {
                            state.layers[index].name = newName;
                            saveStateForUndo("레이어 이름 변경");
                        } else {
                            nameSpan.textContent = state.layers[index].name;
                        }
                        nameSpan.removeEventListener('blur', saveName);
                        nameSpan.removeEventListener('keydown', handleKeydownOnRename);
                    };

                    const handleKeydownOnRename = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            saveName();
                        } else if (e.key === 'Escape') {
                            nameSpan.textContent = state.layers[index].name;
                            saveName();
                        }
                    };
                    nameSpan.addEventListener('blur', saveName, { once: true });
                    nameSpan.addEventListener('keydown', handleKeydownOnRename);
                };

                renameBtn.addEventListener('click', startRename);
                layerItem.addEventListener('click', (e) => {
                    if (e.target !== renameBtn && !renameBtn.contains(e.target)) {
                        setActiveLayer(index);
                    }
                });
            });
        }

        // --- Transform Handle Functions (Refactored) ---
        function updateTransformHandles(cut) {
            dom.transformHandlesContainer.innerHTML = '';
            if (!cut || !cut.characterImg.src || state.isAnimating) return;

            const scaledWidth = dom.canvas.width * cut.characterScale;
            const scaledHeight = (cut.characterImg.height * scaledWidth) / cut.characterImg.width;

            const box = document.createElement('div');
            box.className = 'transform-box';
            
            const boxCenterX = (cut.characterOffsetX + dom.canvas.width / 2);
            const boxCenterY = (cut.characterOffsetY + dom.canvas.height / 2);

            box.style.width = `${scaledWidth}px`;
            box.style.height = `${scaledHeight}px`;
            box.style.left = `${boxCenterX - scaledWidth / 2}px`;
            box.style.top = `${boxCenterY - scaledHeight / 2}px`;
            box.style.transform = `rotate(${cut.rotation}deg)`;

            // Don't show handles if character is locked
            if (!cut.isCharacterLocked) {
                ['tl', 'tr', 'bl', 'br', 'rotate'].forEach(type => {
                    const handle = document.createElement('div');
                    handle.className = `transform-handle ${type}`;
                    handle.dataset.type = type;
                    box.appendChild(handle);
                });
            }

            dom.transformHandlesContainer.appendChild(box);
        }

        function handleCanvasPointerDown(e) {
            if (e.target.id === 'mouth-marker' || e.target.closest('.transform-handle') || e.target.closest('.mouth-handle')) return;
            if (e.type === 'touchstart') e.preventDefault();
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);
            if (!cut || state.isAnimating || cut.isCharacterLocked) return;

            const E = unify(e);
            state.activeTransform = { type: 'character-move', cut, startX: E.clientX, startY: E.clientY, initialOffsetX: cut.characterOffsetX, initialOffsetY: cut.characterOffsetY };

            window.addEventListener('mousemove', handleDocumentPointerMove);
            window.addEventListener('mouseup', handleDocumentPointerUp);
            window.addEventListener('touchmove', handleDocumentPointerMove, { passive: false });
            window.addEventListener('touchend', handleDocumentPointerUp);
        }

        function handleMouthTransformStart(e) {
            if (e.type === 'touchstart') e.preventDefault();
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);
            if (!cut || state.isAnimating || !cut.isCharacterLocked) return;
            
            const E = unify(e);
            const handle = E.target;
            const type = handle.dataset.type;
            const canvasRect = dom.canvas.getBoundingClientRect();
            const charCenterX = cut.characterOffsetX + dom.canvas.width / 2;
            const charCenterY = cut.characterOffsetY + dom.canvas.height / 2;
            const mouthRelativeX = (cut.mouthX - 0.5) * dom.canvas.width;
            const mouthRelativeY = (cut.mouthY - 0.5) * dom.canvas.height;
            const angleRad = cut.rotation * Math.PI / 180;
            const rotatedMouthX = mouthRelativeX * Math.cos(angleRad) - mouthRelativeY * Math.sin(angleRad);
            const rotatedMouthY = mouthRelativeX * Math.sin(angleRad) + mouthRelativeY * Math.cos(angleRad);
            const mouthCenterX = charCenterX + rotatedMouthX;
            const mouthCenterY = charCenterY + rotatedMouthY;

            if (type === 'rotate') {
                 state.activeTransform = { type: 'mouth-rotate', cut, mouthCenterX, mouthCenterY, canvasRect, initialMouthRotation: cut.mouthRotation, startAngle: Math.atan2(E.clientY - canvasRect.top - mouthCenterY, E.clientX - canvasRect.left - mouthCenterX) * 180 / Math.PI };
            } else if (type === 'tl' || type === 'br') {
                 state.activeTransform = { type: 'mouth-resize', cut, mouthCenterX, mouthCenterY, canvasRect, initialMouthSize: cut.mouthSize, startDist: Math.hypot(E.clientX - canvasRect.left - mouthCenterX, E.clientY - canvasRect.top - mouthCenterY) };
            } else { // Move
                 state.activeTransform = { type: 'mouth-move', cut, startX: E.clientX, startY: E.clientY, initialMouthX: cut.mouthX, initialMouthY: cut.mouthY };
            }
            
            window.addEventListener('mousemove', handleDocumentPointerMove);
            window.addEventListener('mouseup', handleDocumentPointerUp);
            window.addEventListener('touchmove', handleDocumentPointerMove, { passive: false });
            window.addEventListener('touchend', handleDocumentPointerUp);
        }

        function handleTransformStart(e) {
            if (e.type === 'touchstart') e.preventDefault();
            const handle = e.target;
            if (!handle.classList.contains('transform-handle')) return;

            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);
            if (!cut) return;
            
            const E = unify(e);
            const type = handle.dataset.type;
            const canvasRect = dom.canvas.getBoundingClientRect();
            const startX = E.clientX, startY = E.clientY;
            const boxCenterX = cut.characterOffsetX + dom.canvas.width / 2;
            const boxCenterY = cut.characterOffsetY + dom.canvas.height / 2;
            
            state.activeTransform = { type: type.startsWith('t') || type.startsWith('b') ? 'resize' : 'rotate', handle: type, cut, startX, startY, canvasRect, boxCenterX, boxCenterY, initialRotation: cut.rotation, startAngle: Math.atan2(startY - canvasRect.top - boxCenterY, startX - canvasRect.left - boxCenterX) * 180 / Math.PI, initialScale: cut.characterScale, startDist: Math.hypot(startX - canvasRect.left - boxCenterX, startY - canvasRect.top - boxCenterY) };
            
            window.addEventListener('mousemove', handleDocumentPointerMove);
            window.addEventListener('mouseup', handleDocumentPointerUp);
            window.addEventListener('touchmove', handleDocumentPointerMove, { passive: false });
            window.addEventListener('touchend', handleDocumentPointerUp);
        }

        function handleDocumentPointerMove(e) {
            if (!state.activeTransform) return;
            if (e.type === 'touchmove') e.preventDefault();
            const { type, cut } = state.activeTransform;
            const E = unify(e);

            switch (type) {
                case 'mouth-move': {
                    const { startX, startY, initialMouthX, initialMouthY } = state.activeTransform;
                    const dx = (E.clientX - startX) / dom.canvas.width;
                    const dy = (E.clientY - startY) / dom.canvas.height;
                    const angleRad = -cut.rotation * Math.PI / 180;
                    const newDx = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                    const newDy = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                    cut.mouthX = initialMouthX + newDx;
                    cut.mouthY = initialMouthY + newDy;
                    break;
                }
                case 'mouth-resize': {
                    const { mouthCenterX, mouthCenterY, canvasRect, startDist, initialMouthSize } = state.activeTransform;
                    const currentDist = Math.hypot(E.clientX - canvasRect.left - mouthCenterX, E.clientY - canvasRect.top - mouthCenterY);
                    const scaleFactor = currentDist / startDist;
                    cut.mouthSize = Math.max(0.01, Math.min(0.5, initialMouthSize * scaleFactor));
                    dom.mouthSizeSlider.value = cut.mouthSize * 100;
                    dom.mouthSizeValue.textContent = Math.round(cut.mouthSize * 100);
                    break;
                }
                case 'mouth-rotate': {
                    const { mouthCenterX, mouthCenterY, canvasRect, startAngle, initialMouthRotation } = state.activeTransform;
                    const currentAngle = Math.atan2(E.clientY - canvasRect.top - mouthCenterY, E.clientX - canvasRect.left - mouthCenterX) * 180 / Math.PI;
                    cut.mouthRotation = initialMouthRotation + (currentAngle - startAngle);
                    break;
                }
                case 'character-move': {
                    const { startX, startY, initialOffsetX, initialOffsetY } = state.activeTransform;
                    const dx = E.clientX - startX;
                    const dy = E.clientY - startY;
                    cut.characterOffsetX = initialOffsetX + dx;
                    cut.characterOffsetY = initialOffsetY + dy;
                    break;
                }
                case 'resize': {
                    const { boxCenterX, boxCenterY, canvasRect, startDist, initialScale } = state.activeTransform;
                    const currentDist = Math.hypot(E.clientX - canvasRect.left - boxCenterX, E.clientY - canvasRect.top - boxCenterY);
                    const scaleFactor = currentDist / startDist;
                    cut.characterScale = Math.max(0.01, initialScale * scaleFactor);
                    dom.characterSizeSlider.value = cut.characterScale * 100;
                    dom.characterSizeValue.textContent = Math.round(cut.characterScale * 100);
                    break;
                }
                case 'rotate': {
                    const { boxCenterX, boxCenterY, canvasRect, startAngle, initialRotation } = state.activeTransform;
                    const currentAngle = Math.atan2(E.clientY - canvasRect.top - boxCenterY, E.clientX - canvasRect.left - boxCenterX) * 180 / Math.PI;
                    cut.rotation = initialRotation + (currentAngle - startAngle);
                    break;
                }
            }
            drawInitialCanvas();
        }

        function handleDocumentPointerUp() {
            if (state.activeTransform) {
                const type = state.activeTransform.type;
                let actionName = "Object Transform";
                if (type.startsWith('mouth')) actionName = "입 모양 변경";
                else if (type === 'character-move') actionName = "캐릭터 이동";
                else if (type === 'resize' || type === 'rotate') actionName = "캐릭터 변형";
                saveStateForUndo(actionName);
            }
            state.activeTransform = null;
            window.removeEventListener('mousemove', handleDocumentPointerMove);
            window.removeEventListener('mouseup', handleDocumentPointerUp);
            window.removeEventListener('touchmove', handleDocumentPointerMove);
            window.removeEventListener('touchend', handleDocumentPointerUp);
        }
        
        // --- Timeline Pan/Zoom Functions ---
        function handleTimelineWheel(e) {
            e.preventDefault();
            if (e.ctrlKey || e.metaKey) { // Zoom
                const timelineRect = dom.timelineViewport.getBoundingClientRect();
                const mouseX = e.clientX - timelineRect.left;
                const timeAtMouse = pxToTime(mouseX);
                const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
                const newZoom = Math.max(0.1, Math.min(state.timelineZoom * zoomFactor, 20));
                const newPan = (timeAtMouse / state.audioDuration) * (dom.timelineViewport.offsetWidth * newZoom) - mouseX;
                state.timelineZoom = newZoom;
                state.timelinePan = newPan;
            } else { // Pan with Shift key or normal wheel
                 state.timelinePan += e.deltaX;
            }
            const maxPan = dom.timelineViewport.offsetWidth * (state.timelineZoom - 1);
            state.timelinePan = Math.max(0, Math.min(state.timelinePan, maxPan));
            renderTimeline();
        }

        function handleTimelinePanStart(e) {
            if (e.button === 1) { // Middle mouse button
                e.preventDefault();
                state.isPanning = true;
                state.lastPanX = e.clientX;
                dom.cutTimelineContainer.style.cursor = 'grabbing';
                
                const onMove = (moveEvent) => {
                    if (!state.isPanning) return;
                    const dx = moveEvent.clientX - state.lastPanX;
                    state.timelinePan -= dx;
                    state.lastPanX = moveEvent.clientX;
                    const maxPan = dom.timelineViewport.offsetWidth * (state.timelineZoom - 1);
                    state.timelinePan = Math.max(0, Math.min(state.timelinePan, maxPan));
                    renderTimeline();
                };
                const onEnd = () => {
                    state.isPanning = false;
                    dom.cutTimelineContainer.style.cursor = 'default';
                    window.removeEventListener('mousemove', onMove);
                    window.removeEventListener('mouseup', onEnd);
                };
                window.addEventListener('mousemove', onMove);
                window.addEventListener('mouseup', onEnd, { once: true });
            }
        }
        
        function handleTimelineTouch(e) {
            e.preventDefault();
            if (e.touches.length === 2) {
                handleTimelinePinchZoom(e);
            } else if (e.touches.length === 1 && state.isPanning) {
                handleTimelineTouchPan(e);
            }
        }
        
        let timelineTouchInitialDistance = 0;
        function handleTimelinePinchZoom(e) {
             const newDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
             if (timelineTouchInitialDistance === 0) {
                 timelineTouchInitialDistance = newDist;
                 return;
             }
             const timelineRect = dom.timelineViewport.getBoundingClientRect();
             const midpointX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - timelineRect.left;
             const timeAtMouse = pxToTime(midpointX);
             const zoomFactor = newDist / timelineTouchInitialDistance;
             const newZoom = Math.max(0.1, Math.min(state.timelineZoom * zoomFactor, 20));
             const newPan = (timeAtMouse / state.audioDuration) * (dom.timelineViewport.offsetWidth * newZoom) - midpointX;

             state.timelineZoom = newZoom;
             state.timelinePan = newPan;

             const maxPan = dom.timelineViewport.offsetWidth * (state.timelineZoom - 1);
             state.timelinePan = Math.max(0, Math.min(state.timelinePan, maxPan));
             renderTimeline();
             timelineTouchInitialDistance = newDist;
        }
        
        function handleTimelineTouchPan(e) {
             const E = unify(e);
             const dx = E.clientX - state.lastPanX;
             state.timelinePan -= dx;
             state.lastPanX = E.clientX;
             const maxPan = dom.timelineViewport.offsetWidth * (state.timelineZoom - 1);
             state.timelinePan = Math.max(0, Math.min(state.timelinePan, maxPan));
             renderTimeline();
        }

        // --- Timeline Drag and Drop for Files ---
        function handleTimelineDragOver(e) {
            e.preventDefault();
            if (!e.dataTransfer.types.includes('Files')) return;

            const targetCutBar = e.target.closest('.timeline-cut-bar');
            if (state.draggedOverCutBarForFile && state.draggedOverCutBarForFile !== targetCutBar) {
                state.draggedOverCutBarForFile.classList.remove('drag-over-file');
            }
            if (targetCutBar) {
                targetCutBar.classList.add('drag-over-file');
                state.draggedOverCutBarForFile = targetCutBar;
            } else {
                state.draggedOverCutBarForFile = null;
            }
        }

        function handleTimelineDragLeave(e) {
            e.preventDefault();
            if (state.draggedOverCutBarForFile) {
                state.draggedOverCutBarForFile.classList.remove('drag-over-file');
                state.draggedOverCutBarForFile = null;
            }
        }

        function handleTimelineDrop(e) {
            e.preventDefault();
            if (state.draggedOverCutBarForFile) {
                state.draggedOverCutBarForFile.classList.remove('drag-over-file');
                const cutId = parseFloat(state.draggedOverCutBarForFile.dataset.id);
                const cut = state.cuts.find(c => c.id === cutId);
                if (cut && e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    processCharacterImage(file, cut);
                }
                state.draggedOverCutBarForFile = null;
            }
        }

        function applyMagnetToActiveLayer() {
            if (state.layers.length === 0) return;
            const activeLayer = state.layers[state.activeLayerIndex];
            if (!activeLayer) return;

            const cutsInLayer = state.cuts
                .filter(c => c.layerId === activeLayer.id)
                .sort((a, b) => a.startTime - b.startTime);

            if (cutsInLayer.length === 0) {
                showNotification("활성 레이어에 정리할 컷이 없습니다.");
                return;
            }
            
            let lastEndTime = 0;
            cutsInLayer.forEach(cut => {
                const duration = cut.endTime - cut.startTime;
                cut.startTime = lastEndTime;
                cut.endTime = cut.startTime + duration;
                lastEndTime = cut.endTime;
            });

            renderTimeline();
            saveStateForUndo("컷 자석 정렬");
            showNotification(`'${activeLayer.name}'의 컷들을 정리했습니다.`);
        }

        function handleDeleteMouth(index) {
            const lastSelectedId = state.selectedCutIds[state.selectedCutIds.length - 1];
            const cut = state.cuts.find(c => c.id === lastSelectedId);
            if (!cut) return;

            cut.mouthImgs[index].img.src = '';
            cut.mouthImgs[index].fileName = null;

            updateEditorUI();
            checkAllFilesReady();
            saveStateForUndo("입모양 삭제");
            showNotification(`${index + 1}번 입모양을 삭제했습니다.`);
        }
        
        function handleLayerPointerDown(e) {
            const E = unify(e);
            const target = E.target.closest('.layer-item');
            if (!target || E.target.closest('.rename-layer-btn')) return;
            if (e.type === 'touchstart') e.preventDefault();

            let draggedItem = null;
            let ghostItem = null;
            let initialY = E.clientY;
            let draggedIndex = parseInt(target.dataset.index, 10);

            const onMove = (moveEvent) => {
                const MOVE_E = unify(moveEvent);
                if (!draggedItem) {
                    // Start dragging only after moving a bit
                    if (Math.abs(MOVE_E.clientY - initialY) < 5) return;
                    
                    draggedItem = target;
                    draggedItem.style.opacity = '0.5';
                    ghostItem = target.cloneNode(true);
                    ghostItem.classList.add('ghost');
                    ghostItem.style.width = `${target.offsetWidth}px`;
                    document.body.appendChild(ghostItem);
                }
                
                ghostItem.style.top = `${MOVE_E.clientY - target.offsetHeight / 2}px`;
                ghostItem.style.left = `${target.getBoundingClientRect().left}px`;
                
                // Drop indicator logic
                const allLayers = Array.from(dom.layerList.querySelectorAll('.layer-item'));
                let overIndex = -1;
                allLayers.forEach((item, index) => {
                    const rect = item.getBoundingClientRect();
                    if (MOVE_E.clientY > rect.top && MOVE_E.clientY < rect.bottom) {
                        overIndex = index;
                    }
                });

                document.querySelectorAll('.drop-indicator').forEach(ind => ind.remove());

                if (overIndex !== -1) {
                    const overItem = allLayers[overIndex];
                    const rect = overItem.getBoundingClientRect();
                    const indicator = document.createElement('div');
                    indicator.className = 'drop-indicator';

                    if (MOVE_E.clientY < rect.top + rect.height / 2) {
                        dom.layerList.insertBefore(indicator, overItem);
                    } else {
                        dom.layerList.insertBefore(indicator, overItem.nextSibling);
                    }
                }
            };
            
            const onEnd = (endEvent) => {
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('mouseup', onEnd);
                window.removeEventListener('touchmove', onMove);
                window.removeEventListener('touchend', onEnd);
                
                if (draggedItem) {
                    draggedItem.style.opacity = '1';
                    ghostItem.remove();

                    const indicator = dom.layerList.querySelector('.drop-indicator');
                    if (indicator) {
                        const allLayers = Array.from(dom.layerList.childNodes).filter(n => n.nodeType === 1);
                        let targetIndex = allLayers.indexOf(indicator);
                        
                        const [movedLayer] = state.layers.splice(draggedIndex, 1);
                        if(targetIndex > draggedIndex) targetIndex--;
                        state.layers.splice(targetIndex, 0, movedLayer);
                        
                        state.activeLayerIndex = state.layers.findIndex(l => l.id === movedLayer.id);
                        saveStateForUndo("레이어 순서 변경");
                        renderLayerList();
                        renderTimeline();
                    }
                    indicator?.remove();
                }
            };
            
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onEnd);
            window.addEventListener('touchmove', onMove, { passive: false });
            window.addEventListener('touchend', onEnd);
        }

        function setupEventListeners() {
            dom.audioUpload.addEventListener('change', handleAudioUpload);
            dom.modeSelect.addEventListener('change', e => { state.mode = e.target.value; });
            dom.deleteCutBtn.addEventListener('click', deleteSelectedCuts);
            
            dom.mouthPreviewsContainer.addEventListener('change', e => {
                if (e.target.tagName === 'INPUT' && e.target.type === 'file') {
                    const dropZone = e.target.closest('.drop-zone');
                    const id = dropZone.id;
                    const index = parseInt(id.replace('mouth-lvl', '').replace('-drop-zone', ''), 10) - 1;
                    handleImageUpload(e, 'mouthImgs', index);
                }
            });
             dom.mouthPreviewsContainer.addEventListener('click', (e) => {
                 if (e.target.classList.contains('delete-mouth-btn')) {
                     const index = parseInt(e.target.dataset.mouthIndex, 10);
                     handleDeleteMouth(index);
                 }
             });
            dom.mouthPreviewsContainer.addEventListener('dragover', e => {
                e.preventDefault();
                const dropZone = e.target.closest('.drop-zone');
                if (dropZone && !dropZone.classList.contains('drag-over')) {
                    const existing = dom.mouthPreviewsContainer.querySelector('.drag-over');
                    if(existing) existing.classList.remove('drag-over');
                    dropZone.classList.add('drag-over');
                }
            });
            dom.mouthPreviewsContainer.addEventListener('dragleave', e => {
                e.preventDefault();
                const dropZone = e.target.closest('.drop-zone');
                if (dropZone && !dropZone.contains(e.relatedTarget)) {
                    dropZone.classList.remove('drag-over');
                }
            });
            dom.mouthPreviewsContainer.addEventListener('drop', e => {
                e.preventDefault();
                const dropZone = e.target.closest('.drop-zone');
                if (dropZone) {
                    dropZone.classList.remove('drag-over');
                    if (e.dataTransfer.files.length > 0) {
                        const input = dropZone.querySelector('input[type="file"]');
                        if (input) {
                            input.files = e.dataTransfer.files;
                            input.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    }
                }
            });


            dom.characterSizeSlider.addEventListener('input', handleCharacterSlider);
            dom.characterSizeSlider.addEventListener('change', () => saveStateForUndo("캐릭터 크기 변경"));
            dom.mouthSizeSlider.addEventListener('input', handleMouthSlider);
            dom.mouthSizeSlider.addEventListener('change', () => saveStateForUndo("입 크기 변경"));
            
            dom.canvas.addEventListener('mousedown', handleCanvasPointerDown);
            dom.canvas.addEventListener('touchstart', handleCanvasPointerDown, { passive: false });
            dom.mouthMarker.addEventListener('mousedown', handleMouthTransformStart);
            dom.mouthMarker.addEventListener('touchstart', handleMouthTransformStart, { passive: false });
            
            dom.playbackTimelineContainer.addEventListener('mousedown', handlePlaybackSeek);
            dom.playbackTimelineContainer.addEventListener('touchstart', handlePlaybackSeek, { passive: false });

            dom.cutTimelineContainer.addEventListener('mousedown', handleCutEditing);
            dom.cutTimelineContainer.addEventListener('touchstart', handleCutEditing, { passive: false });
            
            dom.animateBtn.addEventListener('click', handleAnimateClick);
            dom.resetBtn.addEventListener('click', () => window.location.reload());
            dom.toggleLockBtn.addEventListener('click', handleToggleLock);
            dom.applyMouthsToAllBtn.addEventListener('click', handleApplyMouthsToAll);
            
            dom.canvasContainer.addEventListener('dragover', handleCanvasDragOver);
            dom.canvasContainer.addEventListener('dragleave', handleCanvasDragLeave);
            dom.canvasContainer.addEventListener('drop', handleCanvasDrop);
            
            dom.undoBtn.addEventListener('click', undo);
            dom.redoBtn.addEventListener('click', redo);
            dom.multiSelectToggle.addEventListener('click', () => {
                state.isMultiSelectMode = !state.isMultiSelectMode;
                dom.multiSelectToggle.classList.toggle('bg-blue-200', state.isMultiSelectMode);
                dom.multiSelectToggle.classList.toggle('text-blue-600', state.isMultiSelectMode);
                if (!state.isMultiSelectMode) {
                    if (state.lastSelectedCutId) state.selectedCutIds = [state.lastSelectedCutId];
                    else state.selectedCutIds = [];
                    renderTimeline();
                    updateEditorUI();
                }
            });
            dom.saveProjectBtn.addEventListener('click', saveProject);
            dom.loadProjectUpload.addEventListener('change', handleProjectLoad);
            dom.bgUpload.addEventListener('change', (e) => {
                const cut = state.cuts.find(c => c.id === state.lastSelectedCutId);
                if (cut && e.target.files[0]) processBackgroundImage(e.target.files[0], cut);
            });
            dom.bgFitSelect.addEventListener('change', (e) => {
                const cut = state.cuts.find(c => c.id === state.lastSelectedCutId);
                if (cut) {
                    cut.backgroundFit = e.target.value;
                    drawInitialCanvas();
                    saveStateForUndo("배경 맞춤 변경");
                }
            });
            dom.removeBgBtn.addEventListener('click', () => {
                const cut = state.cuts.find(c => c.id === state.lastSelectedCutId);
                if (cut) {
                    cut.backgroundImage = new Image();
                    updateEditorUI();
                    drawInitialCanvas();
                    saveStateForUndo("배경 제거");
                }
            });
            dom.applyBgToAllBtn.addEventListener('click', handleApplyBgToAll);
            dom.exportBtn.addEventListener('click', handleExportClick);
            dom.exportStartBtn.addEventListener('click', startExport);
            dom.exportCloseBtn.addEventListener('click', closeExportModal);
            dom.exportDownloadBtn.addEventListener('click', () => dom.exportDownloadLink.click());

            dom.handDrawnToggle.addEventListener('change', updateHandDrawnEffect);
            dom.handDrawnIntensitySlider.addEventListener('input', updateHandDrawnEffect);

            dom.addLayerBtn.addEventListener('click', addLayer);
            dom.layerList.addEventListener('mousedown', handleLayerPointerDown);
            dom.layerList.addEventListener('touchstart', handleLayerPointerDown, { passive: false });
            dom.transformHandlesContainer.addEventListener('mousedown', handleTransformStart);
            dom.transformHandlesContainer.addEventListener('touchstart', handleTransformStart, { passive: false });

            // Timeline Pan (Desktop) & Zoom (Desktop)
            dom.cutTimelineContainer.addEventListener('wheel', handleTimelineWheel, { passive: false });
            dom.cutTimelineContainer.addEventListener('mousedown', handleTimelinePanStart);
            
            // Timeline Pan/Zoom (Mobile)
            let touchPanZoomTimeout;
            dom.cutTimelineContainer.addEventListener('touchstart', (e) => {
                if(e.target.closest('.layer-container')) return; // handled by cut editing
                 clearTimeout(touchPanZoomTimeout);
                 if (e.touches.length === 2) {
                     timelineTouchInitialDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                     window.addEventListener('touchmove', handleTimelineTouch, { passive: false });
                 } else if (e.touches.length === 1) {
                     state.isPanning = true;
                     state.lastPanX = e.touches[0].clientX;
                     window.addEventListener('touchmove', handleTimelineTouch, { passive: false });
                 }
                 window.addEventListener('touchend', () => {
                     state.isPanning = false;
                     timelineTouchInitialDistance = 0;
                     window.removeEventListener('touchmove', handleTimelineTouch);
                 }, { once: true });
            }, { passive: false });

            // File Drop
            dom.cutTimelineContainer.addEventListener('dragover', handleTimelineDragOver);
            dom.cutTimelineContainer.addEventListener('dragleave', handleTimelineDragLeave);
            dom.cutTimelineContainer.addEventListener('drop', handleTimelineDrop);

            window.addEventListener('resize', () => {
                drawInitialCanvas();
                renderTimeline();
            });
            window.addEventListener('keydown', handleKeydown);
            setupDropZones();
        }

        function initialize() {
            setupEventListeners();
            addLayer(); // 한 개의 레이어로 시작
            updateEditorUI(); 
            drawInitialCanvas();
            renderTimeline();
            updateUndoRedoButtons();
            updateHandDrawnEffect();
            startHandDrawnAnimation();
        }

        initialize();
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
